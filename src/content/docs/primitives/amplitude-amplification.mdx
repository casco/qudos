---
layout: '@layouts/math.astro'
title: Amplificación de amplitudes
description: Una primitiva cuántica fundamental que permite amplificar las probabilidades de estados deseados en superposiciones cuánticas, facilitando la extracción de información útil en algoritmos como el de Grover.
head:
  - tag: meta
    attrs:
      {
        property: 'og:image',
        content: /qudos/amplitude-amplification/structure.png,
      }
  - tag: meta
    attrs:
      {
        property: 'og:image:alt',
        content: 'Estructura de la primitiva de amplificación de amplitudes (AA) con tres secciones distintivas: preparación, selección y reflejo.',
      }
---

import { Image } from 'astro:assets'
import { Tabs, TabItem, Code, Aside } from '@astrojs/starlight/components'
import Box from '@components/Box.astro'
import QuantumCircuit from '@components/QuantumCircuit.astro'
import Circle from '@components/CircleNotation.astro'
import BibItem from '@components/BibItem.astro'
import Recommendations from '@components/Recommendations.astro'
import ResourceDivider from '@components/ResourceDivider.astro'
import Collapsible from '@components/Collapsible.astro'
import {
  quirk_example,
  qiskit_example,
  qiskit_example_result,
} from '@code-snippets/amplitude-amplification'

La amplificación de amplitudes puede interpretarse como una primitiva cuántica, es decir como un algoritmo que se abstrae de la implementación y que es reutilizable en otros algoritmos. Por ejemplo, el <a href={`${import.meta.env.BASE_URL}/algorithms/grover`}>algoritmo de Grover</a> lo utiliza para un problema de búsqueda en particular. 

## Objetivo

La amplificación de amplitudes busca generalizar el <a href={`${import.meta.env.BASE_URL}/algorithms/grover`}>algoritmo de Grover</a>, preservando la mejora cuadrática y permitiendo la búsqueda sobre un conjunto de elementos no estructurado sin las restricciones impuestas por el mismo. De esta manera, no necesariamente los elementos deben disponerse en una superposición uniforme, y puede haber ninguna, una o varias soluciones. Además, la amplificación de amplitudes pretende funcionar correctamente incluso cuando se desconoce la cantidad de soluciones de antemano. 

## Solución

Si el espacio de búsqueda posee $N$ elementos, es posible poner el foco sobre su índice, el cual puede enumerarse desde $0$ hasta $N - 1$. Así, se asume la igualdad $N = 2^n$ de manera que el índice pueda ser almacenado en $n$ bits. A su vez, el problema puede tener $M$ soluciones, con $0 \leq M \leq N$. Una instancia del problema de búsqueda puede ser representada por una función $\chi$, que toma un entero $x$ como entrada dentro del rango que va desde $0$ hasta $N - 1$. Por definición, $\chi(x) = 1$ si $x$ es la solución del problema, y $\chi(x) = 0$ en caso contrario.

El algoritmo de amplificación de amplitudes se divide en tres partes: la **preparación**, la **selección** y el **reflejo**.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/amplitude-amplification/structure.png`}
    alt='Estructura de la primitiva de amplificación de amplitudes (AA) con tres secciones distintivas, una para la preparación, otra para la selección y otra para el reflejo.'
    width='637'
    height='290'
  />
  <span style='max-width:637px; padding:10px 40px'>
    **Figura (1):** Estructura de la primitiva de amplificación de amplitudes (AA), con superposición uniforme y que selecciona al estado $\ket{0011}$.
  </span>
</div>

### Preparación

La etapa de **preparación** denota una precondición del algoritmo: que el estado cuántico se encuentre en superposición. La forma en la que será implementada dependerá del problema en cuestión. Generalmente, se habla de un algoritmo cuántico $\mathcal{A}$ que no realiza mediciones durante su ejecución, y el resultado de aplicar dicho algoritmo sobre el estado inicial es el siguiente:

```math
\ket{\Psi} = \mathcal{A}\ket{0} 
```

### Selección

En la etapa de **selección**, se provee un circuito que distingue los estados cuánticos a buscar. Esto se hace mediante la modificación de la fase de los estados ``buenos'', es decir, que conforman una solución. Para ello, se acude a la función $\chi$ antes definida.

En el ejemplo provisto en la figura 1, se implementa con una puerta CZ, marcando el estado $\ket{0011}$, por lo que solo se invertirá la fase para dicho estado. Normalmente se utilizan subrutinas más complejas para invertir las fases. Por ejemplo, en ciertos algoritmos esta etapa se implementa utilizando un <a href={`${import.meta.env.BASE_URL}/concepts/oracles#or%C3%A1culo-de-fase`}>oráculo de fase</a>, como ocurre en el <a href={`${import.meta.env.BASE_URL}/algorithms/grover`}>algoritmo de Grover</a>.


### Reflejo

Finaliza con la etapa de **reflejo**, que en ciertas bibliografías se lo llama _operador de difusión_ (Grover) o _inversión sobre la media_ (Nielsen y Chuang). Se **convierten** las diferencias de fases en contrastes de magnitud y se **deselecciona** los estados marcados en el paso previo.

### Iteración

El proceso de amplificación se realiza mediante la aplicación repetida de las etapas de **selección** y **reflejo** sobre el estado resultante de la etapa de **preparación**. Cada iteración comprende la aplicación del siguiente operador unitario:

```math
Q = Q(\mathcal{A}, \chi) = -\mathcal{A} S_0 \mathcal{A}^\dag S_{\chi}
```

Donde $S_{\chi}$ cambia condicionalmente el signo de las amplitudes de los estados buenos, $S_{0}$ cambia el signo de la amplitud si y sólo si el estado es $\ket{0}$, y $\mathcal{A}$ representa un algoritmo cuántico que no realiza mediciones durante su ejecución y, por lo tanto, posee inversa. 

## Análisis

Para evaluar el comportamiento del algoritmo se definen dos conjuntos de cadenas.

```math 
X_0 = \{x \in \Sigma^n: \chi(x) = 0\}\\
X_1 = \{x \in \Sigma^n: \chi(x) = 1\}
```

El conjunto $X_1$ contiene todas las soluciones del problema de búsqueda, mientras que $X_0$ contiene aquellas cadenas que no son soluciones.
Ambos conjuntos satisfacen $X_0 \cap X_1 = \varnothing$ y $X_0 \cup X_1 = \Sigma^n$, lo cual significa que $X_0$ y $X_1$ constituyen una bipartición de $\Sigma^n$ (todas las cadenas de bits de longitud $n$).

Además, se definen dos vectores unitarios que representan los estados de superposición sobre los conjuntos previamente tratados.

```math 
\ket{\Psi_0} = \sum_{x:\chi(x)=0} a_x \ket{x}\\
\ket{\Psi_1} = \sum_{x:\chi(x)=1} a_x \ket{x}
```

Donde $\ket{\Psi_0}$ equivale al estado de superposición de aquellas cadenas que no son soluciones, mientras que $\ket{\Psi_1}$ constituye la superposición de las cadenas que sí lo son. Estos vectores se encuentran definidos únicamente cuando ninguno de los conjuntos es vacío. 

Además, $a = \bra{\Psi_1}\ket{\Psi_1} \ll 1$ es la probabilidad de que la medición de $\ket{\Psi}$ produzca un estado bueno. Así, $1-a = \bra{\Psi_0}\ket{\Psi_0}$ es la probabilidad de que la misma medición produzca un estado malo.

Dado que $\ket{\Psi}$ contiene el estado de superposición inicial sobre todas las cadenas, se cumple la siguiente igualdad:

```math 
\ket{\Psi} = \mathcal{A}\ket{0} = \ket{\Psi_0} + \ket{\Psi_1}
```

Por lo tanto, $\ket{\Psi}$ representa el estado del programa tras la acción de la etapa de **preparación**. Esto implica que justo antes de alcanzar la etapa de **selección**, dicho estado se encuentra contenido en un espacio vectorial abarcado por $\ket{\Psi_0}$ y $\ket{\Psi_1}$. Siempre se tendrá esta propiedad luego de cualquier cantidad de iteraciones al encontrarse en el primer paso de la etapa de **reflejo**.

También considerar que la Amplificación de Amplitudes no se preocupa sobre cuáles cadenas son soluciones, solamente debe ser capaz de distinguirlas respecto de aquellas cadenas que no lo son.

El operador $Q$ definido previamente puede reescribirse como $Q = U_{\Psi} U_{\Psi_0}$, tales que $U_{\Psi} = 2\ket{\Psi}\bra{\Psi} - I$ y $U_{\Psi_0} = \frac{2}{1-a}\ket{\Psi_0}\bra{\Psi_0} - I$, donde $U_{\Psi_0}$ aplica un reflejo en relación al vector de las no soluciones $\ket{\Psi_0}$ y $U_{\Psi}$ refleja respecto del vector $\ket{\Psi}$.

### Visión matricial

Se aplicará $Q$ sobre la base ortonormalizada $\left\{\ket{\psi_0}, \ket{\psi_1}\right\}$ tal que:

```math 
\ket{\psi_0} = \frac{\ket{\Psi_0}}{\sqrt{1-a}}, \ket{\psi_1} = \frac{\ket{\Psi_1}}{\sqrt{a}}
```

Notar que se cumple la siguiente igualdad:

```math 
\ket{\Psi} = \ket{\Psi_0} + \ket{\Psi_1} = \sqrt{1-a} \ket{\psi_0} + \sqrt{a} \ket{\psi_1}
```

Al aplicar $Q$ sobre $\ket{\psi_0}$ se obtiene $(1-2a)\ket{\psi_0} + 2\sqrt{a(1-a)} \ket{\psi_1}$.

<Collapsible title="Cálculo" level="h6">
```math
\begin{align}
Q\ket{\psi_0}&=U_{\Psi}U_{\Psi_0} \ket{\psi_0}\\
&= U_{\Psi} \ket{\psi_0}\\
&= (2\ket{\Psi}\bra{\Psi} - I) \ket{\psi_0}\\
&= 2\ket{\Psi}\bra{\Psi}\ket{\psi_0} - \ket{\psi_0}\\
&= 2\sqrt{1-a}\ket{\Psi} - \ket{\psi_0}\\
&= 2\sqrt{1-a}\left(\sqrt{1-a} \ket{\psi_0} + \sqrt{a} \ket{\psi_1}\right) - \ket{\psi_0}\\
&= 2(1-a)\ket{\psi_0} + 2\sqrt{a(1-a)} \ket{\psi_1} - \ket{\psi_0}\\
&= (1-2a)\ket{\psi_0} + 2\sqrt{a(1-a)} \ket{\psi_1}
\end{align}
```

<Aside>
El producto interno $\bra{\Psi}\ket{\psi_0}$ da como resultado la amplitud del estado de las no soluciones en la base ortonormalizada $\left\{\ket{\psi_0}, \ket{\psi_1}\right\}$, es decir, $\sqrt{1-a}$.
</Aside>
</Collapsible>

Al aplicar $Q$ sobre $\ket{\psi_1}$ se obtiene $-2\sqrt{a(1-a)}\ket{\psi_0} + (1-2a)\ket{\psi_1}$.

<Collapsible title="Cálculo" level="h6">
```math
\begin{align}
Q\ket{\psi_1}&=U_{\Psi}U_{\Psi_0} \ket{\psi_1}\\
&= U_{\Psi} \left(\frac{2}{1-a} \ket{\Psi_0}\bra{\Psi_0} - I \right) \ket{\psi_1}\\
&= U_{\Psi} \left(\frac{2}{1-a} \ket{\Psi_0}\bra{\Psi_0}\ket{\psi_1} - \ket{\psi_1} \right)\\
&= U_{\Psi} \left(0 - \ket{\psi_1} \right)\\
&= -U_{\Psi} \ket{\psi_1}\\
&= -(2\ket{\Psi}\bra{\Psi} - I) \ket{\psi_1}\\
&= (-2\ket{\Psi}\bra{\Psi} + I) \ket{\psi_1}\\
&= -2\ket{\Psi}\bra{\Psi}\ket{\psi_1} + \ket{\psi_1}\\
&= -2\sqrt{a}\ket{\Psi} + \ket{\psi_1}\\
&= -2\sqrt{a}\left(\sqrt{1-a} \ket{\psi_0} + \sqrt{a} \ket{\psi_1}\right) + \ket{\psi_1}\\
&= -2\sqrt{a(1-a)}\ket{\psi_0} + -2a\ket{\psi_1} + \ket{\psi_1}\\
&= -2\sqrt{a(1-a)}\ket{\psi_0} + (1-2a)\ket{\psi_1} 
\end{align}
```

<Aside>
El producto interno $\bra{\Psi_0}\ket{\psi_1}$ da 0 porque son estados ortogonales, mientras que $\bra{\Psi}\ket{\psi_1}$ da como resultado la amplitud del estado de las soluciones en la base ortonormalizada $\left\{\ket{\psi_0}, \ket{\psi_1}\right\}$, es decir, $\sqrt{a}$.
</Aside>
</Collapsible>

Por conveniencia, se expresará la acción de $Q$ en un espacio de dos dimensiones como una matriz.

```math 
M = 
\begin{pmatrix}
1-2a&-2\sqrt{a(1-a)}\\
2\sqrt{a(1-a)}&1-2a\\
\end{pmatrix}
```

donde la primera y segunda fila corresponden a $\ket{\psi_0}$ y $\ket{\psi_1}$ respectivamente. Dicha matriz $M$ se obtiene al multiplicar por sí misma una matriz más simple.

```math
M = 
\begin{pmatrix}
\sqrt{1-a}&-\sqrt{a}\\
\sqrt{a}&\sqrt{1-a}\\
\end{pmatrix}^2
```

<Collapsible title="Cálculo" level="h6">
```math
\begin{align}
M&=\begin{pmatrix}
\sqrt{1-a}&-\sqrt{a}\\
\sqrt{a}&\sqrt{1-a}\\
\end{pmatrix}^2\\
&=\begin{pmatrix}
\sqrt{1-a}&-\sqrt{a}\\
\sqrt{a}&\sqrt{1-a}\\
\end{pmatrix}
\begin{pmatrix}
\sqrt{1-a}&-\sqrt{a}\\
\sqrt{a}&\sqrt{1-a}\\
\end{pmatrix}\\
&=\begin{pmatrix}
\sqrt{1-a}^2 - \sqrt{a}^2&-\sqrt{a(1-a)} - \sqrt{a(1-a)}\\
\sqrt{a(1-a)} + \sqrt{a(1-a)}&-\sqrt{a}^2 + \sqrt{1-a}^2\\
\end{pmatrix}\\
&=\begin{pmatrix}
1-2a&-2\sqrt{a(1-a)}\\
2\sqrt{a(1-a)}&1-2a\\
\end{pmatrix}\\
\end{align}
```
</Collapsible>

Además, la matriz 

```math
\begin{pmatrix}
\sqrt{1-a}&-\sqrt{a}\\
\sqrt{a}&\sqrt{1-a}\\
\end{pmatrix}
```

es de rotación, la cual puede expresarse como 

```math
\begin{pmatrix}
cos(\theta_a)&-sen(\theta_a)\\
sen(\theta_a)&cos(\theta_a)\\
\end{pmatrix}
```

para $\theta_a = sen^{-1}\left(\sqrt{a}\right) = cos^{-1}\left(\sqrt{1-a}\right)$. Utilizando esta nueva expresión:

```math
M = 
\begin{pmatrix}
  cos(\theta_a)&-sen(\theta_a)\\
  sen(\theta_a)&cos(\theta_a)
\end{pmatrix}^2 = 
\begin{pmatrix}
  cos(2\theta_a)&-sen(2\theta_a)\\
  sen(2\theta_a)&cos(2\theta_a)
\end{pmatrix} 
```

ya que rotar por el ángulo $\theta_a$ dos veces es equivalente a rotar por el ángulo $2\theta_a$.

### Visión geométrica

El estado del programa al comienzo de la primera iteración, tras la etapa de **preparación** es:

```math 
\ket{\Psi} = \sqrt{1-a} \ket{\psi_0} + \sqrt{a} \ket{\psi_1} = cos(\theta_a) \ket{\psi_0} + sin(\theta_a) \ket{\psi_1}
```

y el efecto de aplicar $Q$ sobre dicho estado consiste en aplicar una rotación por el ángulo $2\theta_a$ dentro del espacio abarcado por $\ket{\psi_0}$ y $\ket{\psi_1}$.

Por ejemplo: 

```math 
Q^1\ket{\Psi} = cos(3\theta_a) \ket{\psi_0} + sen(3\theta_a) \ket{\psi_1}\\
Q^2\ket{\Psi} = cos(5\theta_a) \ket{\psi_0} + sen(5\theta_a) \ket{\psi_1}\\
Q^3\ket{\Psi} = cos(7\theta_a) \ket{\psi_0} + sen(7\theta_a) \ket{\psi_1}
```

Regla general:

```math 
Q^k\ket{\Psi} = cos((2k+1)\theta_a) \ket{\psi_0} + sen((2k+1)\theta_a) \ket{\psi_1}
```

La idea es que las iteraciones roten el estado vectorial hacia $\ket{\psi_1}$. Cuando esto ocurre, una medición del estado produce con alta probabilidad una de las salidas superpuestas en $\ket{\psi_1}$, es decir, una solución al problema.

Inicialmente el estado vectorial es ortogonal respecto de $\ket{\psi_1}$. Partiendo de este punto, la operación $U_{\Psi_0}$ refleja el estado en torno a $\ket{\psi_0}$, y luego la operación $U_{\Psi}$ lo refleja en torno a $\ket{\Psi}$. Dado que dos reflexiones producen una rotación, el vector de estado se acerca hacia $\ket{\psi_1}$, y luego de reiteradas rotaciones es posible obtener una solución con alta probabilidad mediante una observación en la base computacional.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/amplitude-amplification/geom.jpg`}
    alt='Reflexión realizada al aplicar el oráculo O respecto del estado ortogonal $\ket{A_0}$.'
    width='700'
    height='700'
  />
  <span style='max-width:700px; padding:10px 40px'>
    **Figura (2):** Rotación realizada por el operador $Q$ como composición de dos reflexiones. Fuente: https://alexandre01.github.io/projects/quantum_ampl_estimation/
  </span>
</div>

## Complejidad

Sea $a$ la probabilidad inicial de alcanzar una solución a partir de $\mathcal{A}$. Asumiendo $a > 0$ (existe al menos una solución), y definiendo $t = \left\lfloor \frac{\pi}{4\theta_a} \right\rfloor$, donde $\theta_a$ se define tal que $sen^2(\theta_a) = a$ y $0 \lt \theta_a \leq \frac{\pi}{2}$. Entonces, si se computa $Q^t \mathcal{A} \ket{0}$ (se aplica el operador $Q$ $t$ veces) y se realiza una medición, la salida será buena con probabilidad de al menos $max(1 - a, a)$, definida como el valor más grande entre $1 - a$ y $a$.

De esta manera, el número óptimo de iteraciones es el siguiente:

```math
N_{iteraciones}= \left\lfloor \frac{\pi}{4}\sqrt{\frac{1}{a}} \right\rfloor = \left\lfloor \frac{\pi}{4}\sqrt{\frac{2^n}{s}} \right\rfloor
```

Donde $n$ es la cantidad de cubits y $s$ es la cantidad de soluciones posibles. En caso de que $a$ se desconozca, es posible recurrir a algunas técnicas para resolver el problema conservando la aceleración cuadrática.

<Aside>
  Realizar más iteraciones de las necesarias puede resultar contraproducente ya
  que, si se pasa del número óptimo de iteraciones $\left(N_{iteraciones}
  +1\right)$, el estado cúantico permanecerá seleccionado haciendo que la
  operación de selección funcione de manera insensata.{' '}
</Aside>

<Collapsible title="Demostración" level="h6">

Dado que el estado del programa luego de $t$ iteraciones de $Q$ es 

```math 
Q^t\ket{\Psi} = cos((2t+1)\theta_a) \ket{\psi_0} + sen((2t+1)\theta_a) \ket{\psi_1}
````

debe elegirse $t$ tal que  

```math 
\bra{\psi_1}Q^t\ket{\Psi} = sen((2t+1)\theta_a)
````

sea tan cerca de 1 como sea posible (en valor absoluto), para maximizar la probabilidad de obtener $x \in X_1$ en la medición. También es deseable que $t$ sea lo más pequeño posible, ya que $t$ aplicaciones de la operación $Q$ requieren $t$ consultas a la función $\chi$, cuya ejecución se busca minimizar. Una forma de lograr que $sen((2t+1)\theta_a)$ sea cercano a 1 en valor absoluto consiste en elegir $t$ tal que:

```math 
(2t+1)\theta_a \approx \frac{\pi}{2}
````

Debido al comportamiento de la función seno. 

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/sin_function.png`}
    alt='Comportamiento de la función seno. Probabilidad de leer una solución contra el número de iteraciones.'
    width='700'
    height='700'
  />
  <span style='max-width:700; padding:10px 40px'>
    **Figura (3):** Comportamiento de la función seno. Probabilidad de leer una solución contra el número de iteraciones.
  </span>
</div>

<Aside>
Existen infinitos valores $t$ tal que $sen(t) \approx |1|$. Además, la oscilación de dicha función permite estimar la probabilidad de éxito a la hora de encontrar una solución, basándose en la cantidad de iteraciones elegida. En este contexto, se buscará alcanzar el valor positivo $t$ cercano a $|1|$ más pequeño, con el objetivo de realizar la menor cantidad de iteraciones posible y disminuir al máximo la probabilidad de error durante la ejecución del algoritmo.
</Aside>

Despejando $t$ y redondeando a un valor entero mayor que 0, de la ecuación anterior se obtiene:

```math
t = \left\lfloor\frac{\pi}{4\theta_a}\right\rfloor
```

Ahora debe reemplazarse el valor $\theta_a$. Dado que el valor de dicho ángulo está definido por la fórmula $\theta_a = sen^{-1}\left(\sqrt{a}\right)$, dependiente de $a$, la estimación de $t$ se encuentra ligada a la cantidad de soluciones y la cantidad total de elementos presentes en el espacio de búsqueda. 

</Collapsible>

### Solución única

Se harán los cálculos necesarios para el caso en el que solamente hay una cadena $x$ tal que $\chi(x) = 1$. Esto quiere decir que $s = 1$.

```math
a = \frac{s}{N} = \frac{1}{N}\\
\theta_a = sen^{-1}\left(\sqrt{a}\right) = sen^{-1}\left(\sqrt{\frac{1}{N}}\right)
```

Cuyo valor puede aproximarse a $\sqrt{\frac{1}{N}}$ cuando $N$ es un valor grande. 

Sustituyendo el valor $\theta_a = \sqrt{\frac{1}{N}}$ en la expresión $t = \left\lfloor\frac{\pi}{4\theta_a}\right\rfloor$ se obtiene 

```math
t = \left\lfloor\frac{\pi}{4\theta_a}\right\rfloor = \left\lfloor\frac{\pi}{4N^{-1/2}}\right\rfloor = \left\lfloor\frac{\pi}{4}\sqrt{N}\right\rfloor
```

En base al resultado obtenido en $t$, este caso requiere a lo sumo $O(\sqrt{N})$ consultas para encontrar la solución. La probabilidad de que la medición final resulte en la solución puede expresarse como 

```math
p(N,1)=sen^2((2t+1)θ))
```

Y en general se cumple 

```math
p(N,1) >= 1 - \frac{1}{N}
```

para todo $N$, por lo que la probabilidad de éxito tiende a 1 a medida que $N$ crece.

### Múltiples soluciones

Se harán los cálculos necesarios para el caso en el que hayan distintas cadenas $x_i$ tal que $\chi(x_i) = 1$.

A medida que la cantidad de elementos en $X_1$ varía, también lo hace el ángulo $\theta_a$, lo cual puede repercutir en gran medida en la probabilidad de éxito del algoritmo. Teniendo $s$ soluciones, habrá que usar el siguiente ángulo:

```math
\theta_a=sen^{−1}\left(\sqrt{\frac{s}{N}}\right)
```

y $p(N,s)$ denota la probabilidad del algoritmo para que en $t$ iteraciones encuentre una de las $s$ soluciones dentro de $N$ posibilidades. Puede probarse que 

```math
p(N,s)\geq 1−\frac{s}{N}
```

y también que 

```math
p(N,s)\geq \frac{s}{N}
```

Para todo valor $\alpha \in \{0,1\}$ se cumple que $sen^{-1}(\alpha)\geq\alpha$, por lo que puede afirmarse la siguiente inecuación:

```math
\theta_a = sen^{-1}(\sqrt{a}) = sen^{-1}\left(\sqrt{\frac{s}{N}}\right) \geq \sqrt{\frac{s}{N}}
```

lo cual implica que 

```math
t \leq \frac{\pi}{4\theta_a} \leq \frac{\pi}{4} \sqrt{\frac{N}{s}}
```

Por lo tanto, se reduce la cantidad de consultas requeridas a la función $\chi$ a medida que $s$ aumenta. El número de consultas requeridas es de $O\left(\sqrt{\frac{N}{s}}\right)$.

### Número desconocido de soluciones

Si el número de soluciones $s = |X_1|$ se desconoce debe implementarse una estrategia para encontrar soluciones con alta probabilidad. Existen diferentes alternativas que serán mencionadas a continuación. 

La primera opción consiste en elegir un valor aleatorio de $t$ ubicado entre 1 y $\left\lfloor\frac{\pi}{4}\sqrt{N}\right\rfloor$. De esta manera es posible encontrar una solución (asumiendo que al menos una existe) con una probabilidad mayor al 40\%. Si bien esta probabilidad es baja, repitiendo este procedimiento y verificando el resultado puede alcanzarse una solución con una probabilidad muy cercana a 1. 

Por otro lado, existe un método que encuentra una solución cuando al menos una existe realizando $O\left(\sqrt{\frac{N}{s}}\right)$ consultas, incluso cuando el número de soluciones de $s$ no es conocido. Cabe destacar que se requieren $O\left(\sqrt{N}\right)$ consultas para determinar que no hay soluciones cuando $s=0$. La idea consiste en elegir $t$ de manera uniforme y aleatoria dentro del conjunto $\{1,...,T\}$ iterativamente, incrementando el valor de $T$. Una estrategia válida es comenzar con $T=1$ e incrementar dicho valor exponencialmente, siempre terminando este proceso tan pronto como una solución sea encontrada y dejando de incrementar $T$ para no desperdiciar consultas cuando ya se sabe que no existe una solución. Este procedimiento tiene la ventaja de que requiere menos consultas cuando hay más soluciones. No obstante, debe tenerse cuidado a la hora de elegir la tasa de crecimiento de $T$: está comprobado que utilizar $T \leftarrow \left\lceil \frac{5}{4}T \right\rceil$ funciona correctamente, pero duplicar $T$ en cada iteración es demasiado agresivo y genera incrementos demasiado rápidos. 

### Casos triviales

Si todas las cadenas $x \in \Sigma^n$ son una solución, entonces cualquier medición reflejará una solución; y cuando no haya soluciones, ninguna medición obtendrá una solución. El hecho de que $X_0$ o $X_1$ sean vacíos implica que $\chi$ es una función constante: $X_1$ es vacío cuando $\chi(x) = 0$ para todo $x \in \Sigma^n$ y $X_0$ es vacío cuando $\chi(x) = 1$ para todo $x \in \Sigma^n$. 

Lo anterior implica que 

```math 
S_{\chi}\ket{\Psi} = \pm\ket{\Psi}
```

y por lo tanto 

```math 
Q\ket{\Psi}=(2\ket{\Psi}\bra{\Psi}-I)S_{\chi}\ket{\Psi}=\pm(2\ket{\Psi}\bra{\Psi}-I)\ket{\Psi}=\pm\ket{\Psi}
```

En conclusión, sin importar la cantidad de iteraciones $t$ que se realicen en estos casos, las mediciones siempre reflejarán una cadena aleatoria $x\in\Sigma^n$.


## Ejemplos

Sean $x_1=0001$ y $x_2=0011$ las soluciones a un problema que recurre a la superposición uniforme $\mathcal{A} = H$, se prepara el circuito para distinguir ambas soluciones en la fase de selección. Se sabe de antemano que el problema tiene dos soluciones.

<Tabs>
  <TabItem label='Círculos'>
    <Box>
      Se analizan los pasos del algoritmo donde:
      - $\Gamma_0$ es el estado inicial $\ket{0}$
      - $\Gamma_1$ se corresponde con la preparación del estado cuántico que resulta en $\ket{\Psi}$
      - $\sigma$ representa el resultado de aplicar la operación de selección  
      - $\lambda$ es el efecto de la etapa de reflejo

      En $\sigma$ y $\lambda$ se utilizará como subíndice el número de iteración.

       La cantidad óptima de iteraciones es:
       ```math
        N_{iteraciones}=\left\lfloor \frac{\pi}{4}\sqrt{\frac{2^4}{2}} \right\rfloor=\left\lfloor \frac{\pi}{4}\sqrt{8} \right\rfloor = 2
       ```
       <div style='margin-top:30px'>
         <ResourceDivider icon='pencil' text='\(\Gamma_0\)' />
       </div>
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
        El estado inicial del algoritmo $\ket{0}^{\otimes 4}$
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={1} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{0111}'} />
            </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'0'} prob={0} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       <ResourceDivider icon='pencil' text='\(\Gamma_1\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
         Estado cuántico luego de la preparación (aplicación del algoritmo $\mathcal{A} = H$)
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0011}'} />
              </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0111}'} />
            </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       <ResourceDivider icon='pencil' text='\(\sigma_1\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
           Notar que $\ket{x_1}$ y $\ket{x_2}$ tienen invertida la fase
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'180'} prob={0.0625} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'180'} prob={0.0625} label={'\\ket{0011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{0111}'} />
          </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'0'} prob={0.0625} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       <ResourceDivider icon='pencil' text='\(\lambda_1\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
         Notar la "deselección" de $\ket{0011}$ y $\ket{0001}$
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'180'} prob={0.390625} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'180'} prob={0.390625} label={'\\ket{0011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0111}'} />
         </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       <ResourceDivider icon='pencil' text='\(\sigma_2\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'0'} prob={0.390625} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'0'} prob={0.390625} label={'\\ket{0011}'} />
            </div>                                             
            <div class="quadrant-circles">                     
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{0111}'} />
            </div>                                             
         </section>                                            
         <section class="responsive-circles">                  
            <div class="quadrant-circles">                     
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1011}'} />
            </div>                                             
            <div class="quadrant-circles">                     
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'180'} prob={0.015625} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       <ResourceDivider icon='pencil' text='\(\lambda_2\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
         Notar que no "deselecciona" ya que alcanzó la cantidad óptima de iteraciones.
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'0'} prob={0.472656} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'0'} prob={0.472656} label={'\\ket{0011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0111}'} />
            </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       Llegados a este punto, el problema se encuentra **resuelto** con una probabilidad de 96.875\%, ya que las probabilidades individuales de obtener $\ket{x_1}$ o $\ket{x_2}$ son de 47.2656\%, y sumadas dan la probabilidad total de llegar a una solución. Se realiza una tercera iteración para mostrar el decremento de la probabilidad al exceder la cantidad óptima de iteraciones.
       <ResourceDivider icon='pencil' text='\(\sigma_3\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'180'} prob={0.472656} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'180'} prob={0.472656} label={'\\ket{0011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{0111}'} />
            </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'180'} prob={0.003906} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       <ResourceDivider icon='pencil' text='\(\lambda_3\)' />
       <div style='display: flex; flex-direction:column; align-items:center; margin-bottom:60px'>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{0000}'} />
              <Circle width={'80'} phase={'180'} prob={0.165039} label={'\\ket{0001}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{0010}'} />
              <Circle width={'80'} phase={'180'} prob={0.165039} label={'\\ket{0011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{0100}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{0101}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{0110}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{0111}'} />
            </div>
         </section>
         <section class="responsive-circles">
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1000}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1001}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1010}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1011}'} />
            </div>
            <div class="quadrant-circles">
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1100}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1101}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1110}'} />
              <Circle width={'80'} phase={'0'} prob={0.047852} label={'\\ket{1111}'} />
            </div>
         </section>
       </div>
       Por lo que en una tercera iteración se disminuyen las probabilidades de encontrar una de las soluciones.
    </Box>
  </TabItem>
  <TabItem label='Quirk'>
    <Box>
      <Tabs>
        <QuantumCircuit src={quirk_example}/>
        <Aside>La puerta **flip_x1/x2** permite seleccionar las soluciones $x_1$ y $x_2$. Es implementada de forma similar a lo diagramado en la Figura (1) durante la etapa de selección, en la cual únicamente se distingue $x_2$. Mientras tanto, **mirror** es exactamente igual a la etapa de reflejo de dicha figura.</Aside>
      </Tabs>
    </Box>
  </TabItem>
  <TabItem label='Qiskit'>
    <Box>
      <Tabs>
        <TabItem label='Código'>
          <Code code={qiskit_example} lang='py' />
        </TabItem>
        <TabItem label='Resultado'>
          <Code code={qiskit_example_result} lang='text' />
        </TabItem>
      </Tabs>
    </Box>
  </TabItem>

</Tabs>

## Mas información

<Recommendations />
<BibItem id="oreilly" rate="r" prefix="Capítulo 6, " />
<BibItem id="wong" rate="a" prefix="Capítulo 7.6.3, " />
<BibItem id="nielsen" rate="a" prefix="Capítulo 6.1.2, " />
<BibItem id="groverQiskit" rate="a" />
<BibItem id="amplitudeAmplificationPaper" rate="o" />
<BibItem id="groverPaper" rate="o" />
