---
layout: '@layouts/math.astro'
title: Algoritmo de Grover
description: Un análisis profundo sobre el algoritmo de Grover, sus componentes y sus implicaciones en la computación cuántica.
head:
  - tag: link
    attrs:
      { property: 'og-image', href: /quantum-katas/deutsch-jozsa-simple.png }
---

import { Image } from 'astro:assets'
import { Aside, Code, Tabs, TabItem } from '@astrojs/starlight/components'
import Math from '@components/Math.astro'
import QuantumCircuit from '@components/QuantumCircuit.astro'
import Box from '@components/Box.astro'

import {
  deutsch_none_url,
  deutsch_cx_url,
  deutsch_init_code,
  deutsch_end_code,
  deutsch_none_qiskit,
  deutsch_cx_qiskit,
  deutsch_jozsa_constant_url,
  deutsch_jozsa_balanced_url,
  deutsch_jozsa_code,
  deutsch_jozsa_result_constant,
  deutsch_jozsa_result_balanced,
} from '@code-snippets/deutsch-jozsa'

Moreover, the quantum search algorithm is general in the sense that it can be applied far beyond the route-finding example just described to speed up many (though not all) classical algorithms that use search heuristics.

## Metodología 

Let us begin by setting the stage for the search algorithm in terms of an oracle, similar to
that encountered in Section 3.1.1. This allows us to present a very general description of
the search procedure, and a geometric way to visualize its action and see how it performs.

### El oráculo 

Suppose we wish to search through a search space of N elements. Rather than search the
elements directly, we concentrate on the index to those elements, which is just a number
in the range 0 to N − 1. For convenience we assume N = 2n, so the index can be stored
in n bits, and that the search problem has exactly M solutions, with 1 <= M <= N . A
particular instance of the search problem can conveniently be represented by a function
f , which takes as input an integer x, in the range 0 to N − 1. By definition, f (x) = 1 if
x is a solution to the search problem, and f (x) = 0 if x is not a solution to the search
problem.

Suppose we are supplied with a quantum oracle – a black box whose internal workings
we discuss later, but which are not important at this stage – with the ability to recognize
solutions to the search problem. This recognition is signalled by making use of an oracle
qubit. More precisely, the oracle is a unitary operator, O, defined by its action on the
computational basis:

\ket{x}\ket{q} -> \ket{x}\ket{q mod 2 f(x)} 

where \ket{x} is the index register, ⊕ denotes addition modulo 2, and the oracle qubit \ket{q} is
a single qubit which is flipped if f (x) = 1, and is unchanged otherwise. We can check
whether x is a solution to our search problem by preparing \ket{x}\ket{0}, applying the oracle,
and checking to see if the oracle qubit has been flipped to \ket{1}.

In the quantum search algorithm it is useful to apply the oracle with the oracle qubit
initially in the state (\ket{0} − \ket{1})/√2

If x is not a solution to the search problem, applying the oracle to the state
\ket{x}\ket{-} does not change the state. On the other hand, if x is a solution to the
search problem, then \ket{0} and \ket{1} are interchanged by the action of the oracle, giving a
final state −\ket{x}\ket{-}. The action of the oracle is thus

\ket{x}\ket{-} -> (-1)^f(x)\ket{x}\ket{-}

Demostración:

f(x) = 0: 

\ket{x}\ket{- mod 2 f(x)} = 
\ket{x}\ket{- mod 2 0} = 
\ket{x}(\ket{0} - \ket{1})/sqrt(2) mod 2 0 = 
\ket{x}(\ket{0 mod 2 0} - \ket{1 mod 2 0})/sqrt(2) = 
\ket{x}(\ket{0} - \ket{1})/sqrt(2) = 
\ket{x}\ket{-} = 
1\ket{x}\ket{-} = 
-1^0\ket{x}\ket{-} = 
-1^f(x)\ket{x}\ket{-} = 

f(x) = 1: 

\ket{x}\ket{- mod 2 f(x)} = 
\ket{x}\ket{- mod 2 1} = 
\ket{x}(\ket{0} - \ket{1})/sqrt(2) mod 2 1 = 
\ket{x}(\ket{0 mod 2 1} - \ket{1 mod 2 1})/sqrt(2) = 
\ket{x}(\ket{1} - \ket{0})/sqrt(2) = 
-\ket{x}(-\ket{1} + \ket{0})/sqrt(2) = 
-\ket{x}(\ket{0} - \ket{1})/sqrt(2) = 
-\ket{x}\ket{-} = 
-1\ket{x}\ket{-} = 
-1^1\ket{x}\ket{-} = 
-1^f(x)\ket{x}\ket{-} = 

Notice that the state of the oracle qubit is not changed.
this remains \ket{-} throughout the quantum search algorithm, and can therefore be omitted
from further discussion of the algorithm, simplifying our description.
With this convention, the action of the oracle may be written:

\ket{x} -> (-1)^f(x) \ket{x}

We say that the oracle marks the solutions to the search problem, by shifting the phase
of the solution.

### Procedimiento 

The algorithm begins with the computer in the state \ket{0}⊗n. The Hadamard transform
is used to put the computer in the equal superposition state
1/sqrt(N) sum(0, N - 1, \ket{x})

The quantum search algorithm then consists of repeated application of a quantum
subroutine, know as the Grover iteration or Grover operator, which we denote G

4 steps:
1 - Apply the oracle O.
2 - Apply the Hadamard transform H⊗n.
3 - Perform a conditional phase shift on the computer, with every computational basis
state except \ket{0} receiving a phase shift of −1,

\ket{x} -> -(-1)^delta_x0 \ket{x}

Note: the unitary operator corresponding to the phase shift in the
Grover iteration is 2\ket{0}\bra{0} − I.

4 - Apply the Hadamard transform H⊗n

The combined effect of steps 2,3 and 4 is 

H⊗n(2\ket{0}\bra{0} − I)H⊗n = 
2(H⊗n\ket{0}\bra{0}H⊗n) − I = 

Given that H⊗n gives a uniform superposition u:
2\ket{u}\bra{u} − I 

Thus the Grover iteration G may be written G = (2\ket{u}\bra{u} - I)O 

### Análisis 

Solutions and non-solutions

Let's start by defining two sets of strings.

A_0 = \{x \in \sum{n}: f(x) = 0\}
A_1 = \{x \in \sum{n}: f(x) = 1\}

The set A_1 contains all of the solutions to our search problem, and A_0 contains the strings that aren't solutions 
(which we can refer to as non-solutions when it's convenient). These two sets satisfy A0 ∩ A1= ∅ and A0 ∪ A1=Σn, 
which is to say that this is a bipartition of Σn.

Next we'll define two unit vectors representing uniform superpositions over the sets of solutions and non-solutions.

\ket{A_0} = 1/sqrt(|A_0|) sum(x \in A_0) \ket{x}

\ket{A_1} = 1/sqrt(|A_1|) sum(x \in A_1) \ket{x}

Formally speaking, each of these vectors is only defined when its corresponding set is nonempty, but hereafter we're going 
to focus on the case that neither A_0 nor A_1 is empty.

Let us also define ∣u⟩ to be a uniform quantum state over all nn-bit strings:

\ket{u} = 1/sqrt(N) sum(x \in sum(n), \ket{x})

Notice that:

\ket{u} = sqrt(|A_0|/\N) \ket{A_0} + sqrt(|A_1|/\N) \ket{A_1}

We also have that ∣u⟩=H⊗n∣0n⟩,so ∣u⟩ represents the state of the register Q after the initialization in step 1 of Grover's algorithm. 
This implies that just before the iterations of G happen in step 2, the state of Q is contained in the two-dimensional vector space spanned by 
∣A_0⟩ and ∣A1⟩, and moreover the coefficients of these vectors are real numbers.

As we will see, the state of Q will always have these properties — meaning that the state is a real linear combination of ∣A_0⟩ and ∣A_1⟩ — 
after any number of iterations of the operation G in step 2.

It is important to note that the Grover's algorithm doesn't really care which strings are solutions — 
it only needs to be able to distinguish solutions and non-solutions to operate as it does.

Let's compute the action of G on \ket{A_0} and \ket{A_1}.

Action of G on \ket{A_0}:

G\ket{A_0} = (2\ket{u}\bra{u} - I)O \ket{A_0}
G\ket{A_0} = (2\ket{u}\bra{u} - I) \ket{A_0}
G\ket{A_0} = 2\ket{u}\bra{u}\ket{A_0} - I\ket{A_0}
G\ket{A_0} = 2\ket{u}\bra{u}\ket{A_0} - \ket{A_0}
G\ket{A_0} = 2\sqrt(|A_0|/N)ket{u} - \ket{A_0}
G\ket{A_0} = 2sqrt(|A_0|/N)(sqrt(|A_0|/N) \ket{A_0} + sqrt(|A_1|/N) \ket{A_1}) - \ket{A_0}
G\ket{A_0} = 2|A_0|/N \ket{A_0} + 2sqrt(|A_1||A_0|)/N \ket{A_1}) - \ket{A_0}
G\ket{A_0} = -(1 - 2|A_0|/N) \ket{A_0} + 2sqrt(|A_1||A_0|)/N \ket{A_1} 
G\ket{A_0} = -((|A_1| - |A_0|)/N) \ket{A_0} + 2sqrt(|A_1||A_0|)/N \ket{A_1}
G\ket{A_0} = (|A_0| - |A_1|)/N \ket{A_0} + 2sqrt(|A_1||A_0|)/N \ket{A_1}

Action of G on \ket{A_1}:

G\ket{A_1} = (2\ket{u}\bra{u} - I)O \ket{A_1}
G\ket{A_1} = -(2\ket{u}\bra{u} - I) \ket{A_1}
G\ket{A_1} = -(2\ket{u}\bra{u}\ket{A_1} - I\ket{A_1})
G\ket{A_1} = -2\ket{u}\bra{u}\ket{A_1} + I\ket{A_1}
G\ket{A_1} = -2\ket{u}\bra{u}\ket{A_1} + \ket{A_1}
G\ket{A_1} = -2\sqrt(|A_1|/N)\ket{u} + \ket{A_1}
G\ket{A_1} = -2\sqrt(|A_1|/N)(\sqrt(|A_1|/N) \ket{A_1} + \sqrt(|A_0|/N) \ket{A_0}) + \ket{A_1}
G\ket{A_1} = -2|A_1|/N \ket{A_1} -2\sqrt(|A_1||A_0|)/N \ket{A_0} + \ket{A_1}
G\ket{A_1} = (1 - 2|A_1|/N) \ket{A_1} -2\sqrt(|A_1||A_0|)/N \ket{A_0}
G\ket{A_1} = (|A_0|-|A_1|)/N \ket{A_1} -2\sqrt(|A_1||A_0|)/N \ket{A_0}
G\ket{A_1} = -2\sqrt(|A_1||A_0|)/N \ket{A_0} + (|A_0|-|A_1|)/N \ket{A_1}

We can say that the state of Q just prior to step 2 is contained in the two-dimensional space spanned by ∣A0⟩ and ∣A1⟩.

Expressing the action of G in a two-dimensional space as a matrix:

M = (
(|A_0| - |A_1|)/N         -2sqrt(|A_1||A_0|)/N 
2sqrt(|A_1||A_0|)/N      (|A_0| - |A_1|)/N)
)

whose first and second rows/columns correspond to ∣A0⟩ and ∣A1⟩, respectively. 

The matrix M is what we obtain by squaring a simpler-looking matrix.

(
\sqrt(|A_0|/N)            -\sqrt(|A_1|/N)
\sqrt(|A_1|/N)            \sqrt(|A_0|/N)
)^2

=

(
\sqrt(|A_0|/N)            -\sqrt(|A_1|/N)
\sqrt(|A_1|/N)            \sqrt(|A_0|/N)
) * 
(
\sqrt(|A_0|/N)            -\sqrt(|A_1|/N)
\sqrt(|A_1|/N)            \sqrt(|A_0|/N)
) 

=

(
\sqrt(|A_0|/N)\sqrt(|A_0|/N) + -\sqrt(|A_1|/N)\sqrt(|A_1|/N)      \sqrt(|A_0|/N)-\sqrt(|A_1|/N) + -\sqrt(|A_1|/N)\sqrt(|A_0|/N)
\sqrt(|A_1|/N)\sqrt(|A_0|/N) + \sqrt(|A_0|/N)\sqrt(|A_1|/N)      \sqrt(|A_1|/N)-\sqrt(|A_1|/N) + \sqrt(|A_0|/N)\sqrt(|A_0|/N)
)

=

(
|A_0|/N + -|A_1|/N                              -\sqrt(|A_0||A_1|)/N + -\sqrt(|A_0||A_1|)/N
\sqrt(|A_1||A_0|)/N + \sqrt(|A_0||A_1|)/N       -|A_1|/N + |A_0|/N
)

=

(
|A_0|-|A_1|/N              -2\sqrt(|A_0||A_1|)/N
2\sqrt(|A_1||A_0|)/N       |A_0|-|A_1|/N
)

= 

M

The matrix 

(
\sqrt(|A_0|/N)            -\sqrt(|A_1|/N)
\sqrt(|A_1|/N)            \sqrt(|A_0|/N)
)

is a rotation matrix, which can be expressed as 

(
cos(theta)            -sin(theta)
sin(theta)            cos(theta)
)

for theta = sin^-1(\sqrt(|A_1|/N))

Using this expression for M:

M = 

(
cos(theta)            -sin(theta)
sin(theta)            cos(theta)
)^2 

=

(
cos(theta)^2 -sin(theta)*sin(theta)           cos(theta)(-sin(theta)) + -sin(theta)cos(theta)
sin(theta)cos(theta) + cos(theta)sin(theta)   sin(theta)(-sin(theta)) + cos(theta)^2
)

=

(
cos^2(theta) -sin^2(theta)           -2sincos(theta)
2sincos(theta)                       -sin^2(theta) + cos^2(theta)
)


Another way to see this:

M = 

(
cos(theta)            -sin(theta)
sin(theta)            cos(theta)
)^2 

= 

(
cos(2theta)            -sin(2theta)
sin(2theta)            cos(2theta)
) 

because rotating by the angle theta two times is equivalent to rotating by the angle 2θ.

In summary, the state of the register QQ at the start of step 2 is

\ket{u} = \sqrt(|A_0|/N) \ket{A_0} + \sqrt(|A_1|/N) \ket{A_1} = cos(theta) \ket{A_0} + sin(theta) \ket{A_0}

and the effect of applying G to this state is to rotate it by an angle 2θ within the space spanned by ∣A0⟩ and ∣A1⟩.

For example:

G\ket{u} = cos(3theta) \ket{A_0} + sin(3theta) \ket{A_1}
G^2\ket{u} = cos(5theta) \ket{A_0} + sin(5theta) \ket{A_1}
G^3\ket{u} = cos(7theta) \ket{A_0} + sin(7theta) \ket{A_1}

In general:

G^k\ket{u} = cos((2k+1)theta) \ket{A_0} + sin((2k+1)theta) \ket{A_1}

Repeated application of the Grover iteration rotates the state vector close to \ket{A_1}. When this occurs, an observation in the
computational basis produces with high probability one of the outcomes superposed in \ket{A_1}, that is, a solution to the search problem!

Initially, the state vector is inclined at angle θ from \ket{A_0}, a state orthogonal to \ket{A_1}.
An oracle operation O reflects the state about the state \ket{A_0}, then the operation 2\ket{u}\bra{u} - I reflects it about \ket{u}.
In the figure \ket{A_0} and \ket{A_1} are lengthened slightly to reduce clutter (all states should be unit vectors). After repeated
Grover iterations, the state vector gets close to \ket{A_1}, at which point an observation in the computational basis
outputs a solution to the search problem with high probability. 

#### Número de iteraciones 

The goal is to find an element x∈A1, and this goal will be accomplished if we can obtain the state ∣A1⟩ — for if we measure this state, 
we're guaranteed to get a measurement outcome x∈A1 (under the asumption that x \in A_1 is non empty).

Given that the state of Q after tt iterations in step 2 is

G^t\ket{u} = cos((2t+1)\theta) \ket{A_0} + sin((2t+1)\theta) \ket{A_1}

we should choose tt so that

\bra{A_1}G^t\ket{u} = sin((2t+1)\theta)

is as close to 11 as possible in absolute value, to maximize the probability to obtain x∈A1 from the measurement.

we would also like to choose t to be as small as possible, because t applications of the operation G requires t queries to the function f. 
Because we're aiming to make sin((2t+1)θ) close to 1 in absolute value, a natural way to do this is to choose t so that

(2t+1)\theta ~~ pi/2

because of the behaviour of the function sin.

Solving for t yields:

(2t+1)\theta ~~ pi/2
2t+1 ~~ pi/(2\theta)
2t ~~ pi/(2\theta) - 1
t ~~ (pi/(2\theta) - 1)/2
t ~~ pi/(4\theta) - 1/2

t must be an integer, so we can take the closest integer to this value, which is

t = \floor(pi/4theta)

Recalling that the value of the angle θθ is given by the formula

theta = sin^(-1)(\sqrt(|A_1|/N))

we also see that our estimate t≈π/(4θ)−1/2 depends on the number of strings in A_1. This presents a challenge if we don't know how many solutions we have

##### Unique search 

let's focus on the situation in which there's a single string x such that f(x)=1.

theta = sin^(-1)(\sqrt(1/N)) 

which can be approximated as 

sin^(-1)(\sqrt(1/N)) ~ \sqrt(1/N)

when N gets large.

If we substitute θ=1/N into the expression

t = \floor(pi/4theta)

we get 

t = \floor(pi/(4(\sqrt(1/N))))
t = \floor(pi/4 \sqrt(N))

we see that we're on track to obtaining an algorithm that requires O(sqrt(N)) queries.

The probability that the final measurement results in the unique solution can be expressed explicitly as

p(N,1)=sin^2((2t+1)θ)).

It can be proved in general that

p(N,1) >= 1 - 1/N

for all N, so the probability of success goes to 1 in the limit as N becomes large, as the values produced by the code cell suggest.

#### Multiple solutions

As the number of elements in A_1 varies, so too does the angle θ, which can have a significant significant effect on the algorithm's probability of success

Having s solutions, we'll have to use 

θ=sin^−1(\sqrt(s/N))

p(N,s) denotes the probability that Grover's algorithm run for tt iterations reveals a solution when there are s solutions in total out of N possibilities.

Generalizing what was claimed earlier, it can be proved that

p(N,s)≥1−s/N.

It it also the case that

p(N,s)≥s/N.

For every α∈[0,1] it is the case that sin^−1(α)≥α, and so

theta = sin^-1(\sqrt(s/N)) >= \sqrt(s/N)

this implies that 

t <= pi/4theta <= pi/4 \sqrt(N/s)

This translates to a savings in the number of queries as s grows. In particular, the number of queries required is

O(\sqrt(N/s))



## Objetivo

Este algoritmo resuelve el problema de búsqueda de que una función \\(f\\) sea
**constante** o **balanceada**. Una función es constante cuando \\(f\\) ante cualquier
entrada retorna siempre la misma salida, es decir siempre retorna \\(0\\) o siempre retorna \\(1\\).
Por otra parte la función es balanceada cuando retorna mitad de veces una salida y mitad de veces otra, es decir retorna \\(n/2\\) veces \\(0\\) y \\(1\\) respectivamente.

El **algoritmo clásico**, implica recorrer, en el peor de los casos, al menos mitad de las salidas posibles ($2^{n-1}+1$). El **algoritmo cuántico** realiza esta operación en **una** sola pasada.

## Deutsch-Jozsa reducido

Se plantea en un principio una versión reducida del problema, llamado el problema de Deutsch, donde la función que se evalúa posee una única entrada:

```math
f: \{0,1\} \rightarrow \{0,1\}
```

Esto permite simplificar el algoritmo en su unidad más básica, favoreciendo a que se comprenda el problema que resuelve el algoritmo. Posteriormente se explicará la versión completa del algoritmo de Deutsch-Jozsa para una función con $n$ entradas.

### Solución

Una solución posible al problema reducido definido previamente puede ser el siguiente circuito:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-jozsa-simple.png`}
    alt='Algoritmo Deutsch en un circuito con separadores ante la aplicación de cada compuerta.'
    width='455'
    height='220'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (1):** Algoritmo Deutsch en un circuito con separadores ante la
    aplicación de cada compuerta.
  </span>
</div>

En este circuito cuántico se utilizan las compuertas <a href={`${import.meta.env.BASE_URL}/gates/pauli-x`}>Pauli X</a>, <a href={`${import.meta.env.BASE_URL}/gates/hadamard`}>Hadamard</a> y un <a href={`${import.meta.env.BASE_URL}/concepts/oracles`}>oráculo</a> \\(U_f\\) que es un oráculo de fase. Notar que el oráculo de fase se encuentra asociado a \\(f\\), que es la función que estamos analizando si es constante/balanceada.

Analizaremos paso a paso el estado de los qubits segun los separadores provistos en el grafico, donde \\(\psi_i\\) es el estado en el paso \\(i\\), empezando con \\(i=0\\) y finalizando con \\(i=4\\):

```math
\begin{align}
\psi_0=&\ket{00}\\
\psi_1=&\ket{01}\\
\psi_2=&\ket{+-}\\
\psi_3=&\frac{1}{\sqrt{2}}((-1)^{f(0)}\ket{0}+(-1)^{f(1)}\ket{1})\\
\psi_4=&
\begin{cases}
H\ket{+}=\ket{0} & \text{si \(f(0)=f(1)\)}\\
H\ket{-}=\ket{1} & \text{si \(f(0) \neq f(1)\)}
\end{cases}
\end{align}
```

Un desarrollo elaborado se puede observar dentro de las <a href={`${import.meta.env.BASE_URL}/proofs/deutsch-jozsa#desarrollo-elaborado-de-la-versión-reducida`}>pruebas matemáticas</a>.

La idea básica del algoritmo es poder reemplazar $U_f$ con un circuito, si este circuito representa una función constante, la salida del primer Qubit va a ser $\ket{0}$. Por otra parte, en caso de que el circuito represente una función balanceada, retornará $\ket{1}$.

### Ejemplos

En estos ejemplos se definirán circuitos que representan tanto funciones constantes como balanceadas. Estos circuitos reemplazarán el oráculo definido previamente que abstraía la función a analizar.

<Aside>
  Estos ejemplos tienen como objetivo definir una función para demostrar que el
  algoritmo funciona para un caso, mientras que la versión genérica abarca todos
  los casos.
</Aside>

#### Funciones Constantes

Sea $f$ una función constante, un circuito posible que actue como función constante es no hacer nada.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-fn-constante.png`}
    alt='Circuito con dos qubits, siendo el primero la entrada de la función y el segundo su correspondiente salida. Denota una función constante donde f(x)=0.'
    width='504'
    height='109'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (2):** Circuito con dos qubits, siendo el primero la entrada de la
    función y el segundo su correspondiente salida. Denota una función constante
    donde $f(x)=0$.
  </span>
</div>

Notar que si $x=0$ (primer qubit en el circuito de la izquierda), el resultado de la función $f(x)$ (segundo qubit) es $0$, y de la misma manera si $x=1$ (circuito de la derecha) la salida de $f(x)$ sigue siendo $0$, es decir que $f(0)=f(1)=0$.

Por lo que si introducimos esta función/circuito dentro del algoritmo de Deutsch la salida debe ser $\ket{0}$, gráficamente se observaría de la siguiente manera:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-aplicado-constante.png`}
    alt='Algoritmo Deutsch en un gráfico con separadores ante la aplicación de cada compuerta, utilizando la función constante en vez del oráculo.'
    width='455'
    height='220'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (3):** Algoritmo Deutsch en un gráfico con separadores ante la
    aplicación de cada compuerta, utilizando la función constante en vez del
    oráculo.
  </span>
</div>

Desarrollando paso a paso el estado de los qubits según los separadores provistos:

```math
\begin{align}
\psi_0=&\ket{00}\\
\psi_1=&\ket{01}\\
\psi_2=&\ket{+-}\\
\psi_3=&\ket{0-}\\
=&\ket{0}\\
\end{align}
```

Se elimina el $\ket{-}$ ya que no es utilizado en la medición. Con este resultado llegamos rapidamente a que, con este ejemplo de función constante, se deriva correctamente al resultado de $\ket{0}$.

<Tabs>
  <TabItem label='Quirk'>
    <Box>
      <QuantumCircuit src={deutsch_none_url} />
    </Box>
  </TabItem>
  <TabItem label='Qiskit'>
    <Box>
      <Code code={deutsch_none_qiskit} lang='py' mark={['# no hace nada']} />
    </Box>
  </TabItem>
</Tabs>

La función descrita previamente era constante y retornaba 0 ante cualquier input. Otro ejemplo de función constante es aquella que siempre retorna 1 como salida, esta se puede implementar por ejemplo aplicando una compuerta Pauli-X a la salida.

#### Funciones Balanceadas

Sea $f$ una función balanceada, un circuito posible que representa una función balanceada es utilizando una compuerta CNOT.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-fn-balanceada.png`}
    alt='Circuito con dos qubits, siendo el primero la entrada de la función y el segundo su correspondiente salida. Denota una función balanceada'
    width='504'
    height='109'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (4):** Circuito con dos qubits, siendo el primero la entrada de la
    función y el segundo su correspondiente salida. Denota una función
    balanceada.
  </span>
</div>

Notar que si $x=0$ (primer qubit en el circuito de la izquierda), el resultado de la función $f(x)$ (segundo qubit) es $0$, y si $x=1$ (circuito de la derecha) la salida de $f(x)$ es $1$, es decir que $f(0)\neq f(1)$.

Si introducimos esta función/circuito dentro del algoritmo de Deutsch la salida, a diferencia del previo, debe ser $\ket{1}$, gráficamente se observaria de la siguiente manera:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-aplicado-balanceada.png`}
    alt='Algoritmo Deutsch en un gráfico con separadores ante la aplicación de cada compuerta, utilizando la función balanceada en vez del oráculo.'
    width='455'
    height='220'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (5):** Algoritmo Deutsch en un gráfico con separadores ante la
    aplicación de cada compuerta, utilizando la función balanceada en vez del
    oráculo.
  </span>
</div>

Nuevamente desarrollando paso a paso los estados de los qubits en cada separador obtenemos:

```math
\begin{align}
\psi_0=&\ket{00}\\
\psi_1=&\ket{01}\\
\psi_2=&\ket{+-}\\
\psi_3=&CNOT\ket{+-}\\
      =&\ket{--}\\
\psi_4=&\ket{1-}\\
=&\ket{1}
\end{align}
```

Una derivación del paso $\psi_3$ se puede encontrar en las <a href={`${import.meta.env.BASE_URL}/proofs/cnot`}>pruebas matemáticas de CNOT</a>. De la misma manera se elimina el $\ket{-}$ ya que no se utiliza en la medición.

Esto determina que, para este ejemplo de función balanceada, se deriva al resultado correcto, es decir que el circuito con <a href={`${import.meta.env.BASE_URL}/gates/cnot`}>CNOT</a> deriva en el resultado $\ket{1}$.

<Tabs>
  <TabItem label='Quirk'>
    <Box>
      <QuantumCircuit src={deutsch_cx_url} />
      <Aside>
        A diferencia del ejemplo previo de función constante, en este, cambió el
        estado de ***"Off"*** a ***"On"***.
      </Aside>
    </Box>
  </TabItem>
  <TabItem label='Qiskit'>
    <Box>
      <Code code={deutsch_cx_qiskit} lang='py' mark={['qc.cx(0, 1)']} />
    </Box>
  </TabItem>
</Tabs>

La función descrita previamente era balanceada retornando el mismo valor que el input (función identidad). Otro ejemplo de función balanceada es aquella que siempre retorna el opuesto de la entrada como salida (función de opuesto), esta se puede implementar, por ejemplo, aplicando una compuerta Pauli-X a la salida luego de haber aplicado un CNOT.

## Deutsch-Jozsa completo

El problema que resuelve el algoritmo de Deutsch-Jozsa es la generalización del algoritmo previo para funciones con $n$ entradas:

```math
f: \{0,1\}^n \rightarrow \{0,1\}
```

### Solución

El algoritmo de Deutsch-Jozsa se describe de forma genérica con el siguiente circuito:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-jozsa-completo.png`}
    alt='Algoritmo Deutsch-Jozsa en un circuito con separadores ante la aplicación de cada compuerta.'
    width='455'
    height='182'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (6):** Algoritmo Deutsch-Jozsa en un circuito con separadores ante
    la aplicación de cada compuerta.
  </span>
</div>

Este mantiene una estructura similar al algoritmo de Deutsch planteado en la figura 1 pero con algunos cambios:

- Se reemplaza el segundo qubit de $\ket{0}$ a $\ket{-}$, esto es equivalente a aplicar una compuerta Pauli-X y Hadamard pero se evitó para tener una mayor legibilidad.

- Se generaliza el qubit de entrada a $n$ qubits que representan los valores de entrada, esto esta representado por el símbolo / $^n$ previo a $\psi_0$.

- Se aplican las compuertas Hadamard a los $n$ qubits de entrada y el oráculo es aplicado a los $n$ qubits de entrada y al qubit que representa la salida de la función.

Analizaremos paso a paso el estado de los qubits segun los separadores provistos en el grafico, donde \\(\psi_i\\) es el estado en el paso \\(i\\), empezando con \\(i=0\\) y finalizando con \\(i=3\\):

```math
\begin{align}
\psi_0=&\ket{0}^{\otimes n}\ket{-}\\
\psi_1=&H^{\otimes n}\ket{0}^{\otimes n}\ket{-}\\
=&\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n} \ket{x}\ket{-}\\
\psi_2=&U_f\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n} \ket{x}\ket{-}\\
=&\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n} (-1)^{f(x)}\ket{x}\\
\psi_3=&H^{\otimes n}\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n} (-1)^{f(x)}\ket{x}\\
=&\sum_{z\in\{0,1\}^n} \left(\frac{1}{2^n}\sum_{x\in\{0,1\}^n} (-1)^{f(x)+x\cdot z}\right) \ket{z}\\
\end{align}
```

Un desarrollo elaborado de los pasos se puede observar dentro de las <a href={`${import.meta.env.BASE_URL}/proofs/deutsch-jozsa#desarrollo-elaborado-de-la-versión-completa`}>pruebas matemáticas</a>. Finalmente si medimos la amplitud del estado $\psi_3$ donde $\ket{z}$ es $\ket{0}^{\otimes{n}}$ (<a href={`${import.meta.env.BASE_URL}/proofs/deutsch-jozsa#mediciones`}>ver desarrollo</a>):

```math
\begin{gather}
\left|\frac{1}{2^n}\sum_{x\in\{0,1\}^n} (-1)^{f(x)+x\cdot 00\ldots 0}\right|^2=\left|\frac{1}{2^n}\sum_{x\in\{0,1\}^n} (-1)^{f(x)}\right|^2\\
\end{gather}
```

Estas amplitudes convergen en diferentes resultados según si $f$ es constante o balanceada, por un lado si es **_constante_** (<a href={`${import.meta.env.BASE_URL}/proofs/deutsch-jozsa#función-constante`}>ver prueba completa</a>):

```math
\begin{align}
\left|\frac{1}{2^n}\sum_{x\in\{0,1\}^n} (-1)^{f(x)}\right|^2=1
\end{align}
```

Por otro lado si es **_balanceada_** (<a href={`${import.meta.env.BASE_URL}/proofs/deutsch-jozsa#función-balanceada`}>ver prueba completa</a>):

```math
\begin{align}
\left|\frac{1}{2^n}\sum_{x\in\{0,1\}^n} (-1)^{f(x)}\right|^2=0
\end{align}
```

Ahora, a diferencia del algoritmo previo, se puede reemplazar $U_f$ con un circuito que represente una función constante o una función balanceada con $n$ entradas, en caso de ser del primer tipo la probabilidad de medir $\ket{0}^{\otimes n}$ es $1$, y en caso de ser del segundo tipo la probabilidad de medir $\ket{0}^{\otimes n}$ es $0$.

### Ejemplos

Sea $f$ una función con 3 entradas y una salida, se debe codificar este oráculo en el circuito de Deutsch-Jozsa.

<Tabs>
  <TabItem label='Quirk'>
    <Box>
        <Tabs>
            <TabItem label='Función constante'>
                <QuantumCircuit src={deutsch_jozsa_constant_url} />
            </TabItem>
            <TabItem label='Función balanceada'>
                <QuantumCircuit src={deutsch_jozsa_balanced_url}/>
            </TabItem>
        </Tabs>
    </Box>
  </TabItem>
  <TabItem label='Qiskit'>
    <Box>
        <Tabs>
            <TabItem label='Código'>
                <Code lang="py" code={deutsch_jozsa_code}/>
            </TabItem>
            <TabItem label='Resultado constante'>
                <Code lang="py" code={deutsch_jozsa_result_constant}/>
            </TabItem>
            <TabItem label='Resultado balanceada'>
                <Code lang="py" code={deutsch_jozsa_result_balanced}/>
            </TabItem>
        </Tabs>
    </Box>
  </TabItem>

</Tabs>
## Más información

- Páginas 248-276, <a href='https://isbnsearch.org/isbn/9781107002173' target='_blank'>Quantum Computation and Quantum Information: 10th Anniversary Edition (Michael A. Nielsen; Isaac L. Chuang) [Inglés]</a>
- <a href="https://learning.quantum.ibm.com/course/fundamentals-of-quantum-algorithms/grovers-algorithm" target="_blank">Grover's algorithm (IBM) [Inglés]</a>
- <a href="https://quantum.country/search">How the quantum search algorithm works [Inglés]</a>
