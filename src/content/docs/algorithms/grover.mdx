---
layout: '@layouts/math.astro'
title: Algoritmo de Grover
description: Un análisis profundo sobre el algoritmo de Grover, su funcionamiento, componentes y cómo acelera la búsqueda en conjuntos no estructurados mediante técnicas cuánticas.
head:
  - tag: meta
    attrs:
      { property: 'og:image', content: /qudos/grover/grover-algorithm.png }
  - tag: meta
    attrs:
      { property: 'og:image:alt', content: 'Algoritmo de Grover en un circuito cuántico utilizando la amplificación de amplitudes.' }
---

import { Image } from 'astro:assets'
import { Aside, Card, Code, Tabs, TabItem } from '@astrojs/starlight/components'
import QuantumCircuit from '@components/QuantumCircuit.astro'
import BibItem from '@components/BibItem.astro'
import Recommendations from '@components/Recommendations.astro'
import Box from '@components/Box.astro'
import {
  solution_grover,
  results_11_grover,
  grover_example
} from '@code-snippets/grover'


El algoritmo de Grover es el algoritmo de búsqueda cuántico por excelencia, ya que permite encontrar un elemento dentro de un conjunto de elementos no estructurado. Es muy importante porque puede aplicarse sobre diferentes clases de problemas y acelerar los algoritmos clásicos que usan heurísticas de búsqueda. 

## Objetivo

Dada una base de datos no ordenada de $N$ elementos, de la cual sólo uno de ellos satisface una propiedad en particular, se quiere encontrar dicho elemento. El mejor algoritmo clásico conocido realiza esta tarea en $O(N)$ pasos, mientras que este algoritmo puede resolverlo en $O(\sqrt{N})$ pasos.

## Metodología 

Se emplea el algoritmo de búsqueda en términos de un oráculo. Esto permite presentar una descripción general del proceso de búsqueda, junto con un punto de vista geométrico para ver cómo funciona. Además, facilita el análisis de complejidad, poniendo bajo consideración únicamente la cantidad de consultas realizadas al oráculo durante la ejecución del algoritmo.

### Oráculo 

Se desea buscar sobre un espacio de búsqueda de $N$ elementos. En lugar de buscar dichos elementos directamente, se pondrá el foco sobre su índice,
el cual puede enumerarse desde $0$ hasta $N - 1$. Se asumirá $N = 2^n$, de manera que el índice pueda ser almacenado en $n$ bits, y el problema tendrá exactamente 
$1$ solución. Una instancia del problema de búsqueda puede ser representada por una función $f$, que toma un entero $x$ como entrada dentro 
del rango que va desde $0$ a $N - 1$. Por definición, $f(x) = 1$ si $x$ es la solución del problema, y $f(x) = 0$ en caso contrario.

La función $f$ antes definida se asume implementada por medio de un oráculo cuántico con la habilidad para reconocer soluciones al problema de búsqueda. 
Precisamente, se trata de un <a href={`${import.meta.env.BASE_URL}/concepts/oracles#oráculo-de-fase`}>oráculo de fase</a>, encargado de marcar las soluciones del problema de búsqueda, modificando su fase.

### Procedimiento 

Los pasos llevados a cabo en este algoritmo se corresponden con la metodología general de la <a href={`${import.meta.env.BASE_URL}/primitives/amplitude-amplification`}>amplificación de amplitudes (AA)</a>, implementada de manera específica para el problema planteado en este artículo.

El oráculo antes definido se llamará $O$, mientras que se denominará $Q$ al registro asociado a los $n$ cubits que codifican la información de la base de búsqueda, excluyendo así a los cubits adicionales que serán utilizados para la ejecución del oráculo.

El algoritmo comienza en el estado $\ket{0}^{\otimes n}$. Así, se introduce la etapa de **preparación**, aplicando la transformación de Hadamard para alcanzar un estado de superposición uniforme $\frac{1}{\sqrt N} \sum_{0}^{N - 1}\ket{x}$ sobre todas las soluciones en el espacio de búsqueda. 

A continuación, el algoritmo de búsqueda consiste en la aplicación reiterada de una subrutina cuántica, conocida como iteración de Grover, que es representada mediante la letra $G$ y consta de los siguientes pasos:

1. Etapa de **selección**. Llevada a cabo mediante la aplicación del oráculo O. 
2. Etapa de **reflejo**. Debido a que en este problema se tratan superposiciones uniformes, se aplican los siguientes pasos:
- Aplicar la transformación de Hadamard $H^{\otimes n}$
- Realizar un cambio de fase condicional, con todos los estados a excepción de $\ket{0}$ recibiendo un cambio de fase con valor $-1$,
```math
\ket{x} \rightarrow -(-1)^{\delta_{x0}} \ket{x}
```
- Aplicar la transformación de Hadamard $H^{\otimes n}$

*Nota: el operador unitario correspondiente al cambio de fase es $2\ket{0}\bra{0} - I$.*

El efecto de la etapa de **reflejo** se encuentra desarrollado a continuación.

```math
\begin{align}
H^{\otimes n}(2\ket{0}\bra{0} - I)H^{\otimes n}&=\\
2(H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}) - I&=\\
2\ket{u}\bra{u} - I
\end{align}
```

Debido a que aplicar $H^{\otimes n}$ da como resultado una superposición uniforme $u$.

Así, la iteración de Grover $G$ puede escribirse de la siguiente manera:

```math
G = (2\ket{u}\bra{u} - I)O
```

En términos de la <a href={`${import.meta.env.BASE_URL}/primitives/amplitude-amplification`}>amplificación de amplitudes</a>, $\mathcal{A} = H$, ya que se aplica una superposición uniforme para todos los elementos sobre el estado inicial $\ket{0}$. Además, $S_\chi = O$, debido a que la distinción de la solución es empleada por medio del oráculo previamente definido. Así, el operador $Q$ toma la siguiente forma:

```math 
Q = -HS_0HO
```

Dado que la probabilidad inicial de éxito $a$ es exactamente $\frac{1}{N}$ (existe una única solución al problema), si se mide luego de $m = \left\lfloor \frac{\pi}{4\theta_a} \right\rfloor$ iteraciones de $Q$, la probabilidad de encontrar la solución tiene una cota inferior de $1 - \frac{1}{N}$.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/grover-algorithm.png`}
    alt='Algoritmo de Grover en un circuito cuántico utilizando la iteración de Grover G.'
    width='500'
    height='500'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (1):** Algoritmo de Grover en un circuito cuántico utilizando la iteración de Grover G.
  </span>
</div>

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/grover-iteration.png`}
    alt='Iteración de Grover G en un circuito cuántico.'
    width='500'
    height='500'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (2):** Iteración de Grover G en un circuito cuántico.
  </span>
</div>

### Análisis 

#### Comportamiento

Para evaluar el comportamiento del algoritmo se definirán dos conjuntos de cadenas.

```math 
A_0 = \{x \in \Sigma^n: f(x) = 0\}\\
A_1 = \{x \in \Sigma^n: f(x) = 1\}
```

El conjunto $A_1$ contiene todas las soluciones del problema de búsqueda, mientras que $A_0$ contiene aquellas cadenas que no son soluciones.
Ambos conjuntos satisfacen $A_0 \cap A_1 = \varnothing$ y $A_0 \cup A_1 = \Sigma^n$, lo cual significa que $A_0$ y $A_1$ constituyen una bipartición de $\Sigma^n$.

Además, se definirán dos vectores unitarios que representan las superposiciones uniformes sobre los conjuntos previamente tratados.

```math 
\ket{A_0} = \frac{1}{\sqrt{|A_0|}} \sum_{x \in A_0} \ket{x}\\
\ket{A_1} = \frac{1}{\sqrt{|A_1|}} \sum_{x \in A_1} \ket{x}
```

Notar que estos vectores se encuentran definidos únicamente cuando ninguno de los conjuntos es vacío.
Haciendo uso nuevamente de $\ket{u}$ para referir al estado cuántico uniforme sobre las cadenas de $n$ bits:

```math 
\ket{u} = \frac{1}{\sqrt N} \sum_{x \in \Sigma^n} \ket{x}
```

Esto puede representarse también como:

```math 
\ket{u} = \sqrt{\frac{|A_0|}{N}} \ket{A_0} + \sqrt{\frac{|A_1|}{N}} \ket{A_1}
```

Recordar que también se cumple $\ket{u} = H^{\otimes n}\ket{0^n}$, de manera que $\ket{u}$ representa el estado del registro $Q$ tras realizar la etapa de **preparación** del algoritmo de Grover. Esto implica que justo antes de alcanzar la etapa de **selección**, el estado de $Q$ se encuentra contenido en un espacio vectorial de dos dimensiones abarcado por $\ket{A_0}$ y $\ket{A_1}$, y los coeficientes de ambos vectores son números reales. Notar que $Q$ siempre tendrá esta propiedad luego de cualquier cantidad de iteraciones de $G$ en el primer paso de la etapa de **reflexión**.

Otro punto importante a considerar es que el algoritmo de Grover no se preocupa sobre cuáles cadenas son soluciones, solamente debe ser capaz de distinguirlas respecto de aquellas cadenas que no lo son.

Al aplicar $G$ sobre $\ket{A_0}$ se obtiene:

```math
\frac{|A_0| - |A_1|}{N} \ket{A_0} + 2\frac{\sqrt{|A_1|\cdot|A_0|}}{N} \ket{A_1}
```

Mientras que aplicar $G$ sobre $\ket{A_1}$ produce:

```math
-2\frac{\sqrt{|A_0| \cdot |A_1|}}{N} \ket{A_0} + \frac{|A_0| - |A_1|}{N} \ket{A_1}
```

Por conveniencia, se expresará la acción de $G$ en un espacio de dos dimensiones como una matriz.

```math 
M = 
\begin{pmatrix}
\frac{|A_0| - |A_1|}{N}&-2\frac{\sqrt{|A_0||A_1|}}{N}\\
2\frac{\sqrt{|A_0||A_1|}}{N}&\frac{|A_0| - |A_1|}{N}\\
\end{pmatrix}
```

donde la primera y segunda fila/columna corresponden a $\ket{A_0}$ y $\ket{A_1}$ respectivamente. Dicha matriz $M$ se obtiene al multiplicar 
por sí misma una matriz más simple.

```math
M = 
\begin{pmatrix}
\sqrt{\frac{|A_0|}{N}}&-\sqrt{\frac{|A_1|}{N}}\\
\sqrt{\frac{|A_1|}{N}}&\sqrt{\frac{|A_0|}{N}}\\
\end{pmatrix}^2
```

Además, la matriz 

```math
\begin{pmatrix}
\sqrt{\frac{|A_0|}{N}}&-\sqrt{\frac{|A_1|}{N}}\\
\sqrt{\frac{|A_1|}{N}}&\sqrt{\frac{|A_0|}{N}}\\
\end{pmatrix}
```

es de rotación, la cual puede expresarse como 

```math
\begin{pmatrix}
cos(\theta)&-sin(\theta)\\
sin(\theta)&cos(\theta)\\
\end{pmatrix}
```

para $\theta = sin^{-1}\left(\sqrt{\frac{|A_1|}{N}}\right)$. Utilizando esta nueva expresión para $M$:

```math
\begin{align}
  M =& 
  \begin{pmatrix}
    cos(\theta)&-sin(\theta)\\
    sin(\theta)&cos(\theta)\\
  \end{pmatrix}^2\\

  =& 
  \begin{pmatrix}
    cos^2(\theta)-sin^2(\theta)&-cos(\theta)sin(\theta) - cos(\theta)sin(\theta)\\
    cos(\theta)sin(\theta) + cos(\theta)sin(\theta)&cos^2(\theta) - sin^2(\theta)\\
  \end{pmatrix}^2\\

  =& 
  \begin{pmatrix}
    cos^2(\theta)-sin^2(\theta)&-2cos(\theta)sin(\theta)\\ 
    2cos(\theta)sin(\theta)&cos^2(\theta) - sin^2(\theta)\\
  \end{pmatrix}^2
\end{align}
```

Otra igualdad que se puede alcanzar sin hacer cálculos es

```math
M = 
\begin{pmatrix}
  cos(\theta)&-sin(\theta)\\
  sin(\theta)&cos(\theta)
\end{pmatrix}^2 = 
\begin{pmatrix}
  cos(2\theta)&-sin(2\theta)\\
  sin(2\theta)&cos(2\theta)
\end{pmatrix} 
```

ya que rotar por el ángulo $\theta$ dos veces es equivalente a rotar por el ángulo $2\theta$.

Retomando, el estado del registro $Q$ al comienzo del paso de la iteración de Grover es 

```math 
\ket{u} = \sqrt{\frac{|A_0|}{N}} \ket{A_0} + \sqrt{\frac{|A_1|}{N}} \ket{A_1} = cos(\theta) \ket{A_0} + sin(\theta) \ket{A_1}
```

y el efecto de aplicar $G$ sobre dicho estado consiste en aplicar una rotación por el ángulo $2\theta$ dentro del espacio abarcado por $\ket{A_0}$ y $\ket{A_1}$.

Por ejemplo: 

```math 
G^1\ket{u} = cos(3\theta) \ket{A_0} + sin(3\theta) \ket{A_1}\\
G^2\ket{u} = cos(5\theta) \ket{A_0} + sin(5\theta) \ket{A_1}\\
G^3\ket{u} = cos(7\theta) \ket{A_0} + sin(7\theta) \ket{A_1}
```

Regla general:

```math 
G^k\ket{u} = cos((2k+1)\theta) \ket{A_0} + sin((2k+1)\theta) \ket{A_1}
```

La idea es que la iteración de Grover rote el estado vectorial hacia $\ket{A_1}$. Cuando esto ocurre, una medición del estado produce con alta probabilidad 
una de las salidas superpuestas en $\ket{A_1}$, es decir, una solución al problema.

Inicialmente el estado vectorial es ortogonal respecto de $\ket{A_1}$. Partiendo de este punto, la operación del oráculo $O$ refleja el estado en torno a $\ket{A_0}$, y luego la operación $2\ket{u}\bra{u} - I$ lo refleja en torno a $\ket{u}$. Dado que dos reflexiones producen una rotación, el vector de estado se acerca hacia $\ket{A_1}$, y luego de reiteradas rotaciones es posible obtener una solución con alta probabilidad mediante una observación en la base computacional.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/reflection1.jpg`}
    alt='Reflexión realizada al aplicar el oráculo O respecto del estado ortogonal $\ket{A_0}$.'
    width='700'
    height='700'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (3):** Reflexión realizada al aplicar el oráculo O respecto del estado ortogonal $\ket{A_0}$.
  </span>
</div>

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/reflection2.jpg`}
    alt='Reflexión realizada al aplicar el cambio de fase condicional respecto del estado $\ket{u}$.'
    width='700'
    height='700'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (4):** Reflexión realizada al aplicar el cambio de fase condicional respecto del estado $\ket{u}$.
  </span>
</div>

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/rotation.jpg`}
    alt='Rotación obtenida como producto de haber realizado ambas reflexiones, provocando un acercamiento hacia $\ket{A_1}$.'
    width='700'
    height='700'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (5):** Rotación obtenida como producto de haber realizado ambas reflexiones, provocando un acercamiento hacia $\ket{A_1}$.
  </span>
</div>

#### Número de iteraciones

En este apartado se evaluará la cantidad de iteraciones necesarias para hallar una solución utilizando el algoritmo de Grover. 

El objetivo consiste en encontrar un elemento $x \in A_1$, y esto se cumplirá cuando se obtenga el estado $\ket{A_1}$, el cual nos garantizará que 
se obtendrá un valor $x \in A_1$ como resultado de la medición.

Dado que el estado $Q$ luego de $t$ iteraciones de $G$ es 

```math 
G^t\ket{u} = cos((2t+1)\theta) \ket{A_0} + sin((2t+1)\theta) \ket{A_1}
````

debe elegirse $t$ tal que  

```math 
\bra{A_1}G^t\ket{u} = sin((2t+1)\theta)
````

sea tan cerca de 1 como sea posible (en valor absoluto), para maximizar la probabilidad de obtener $x \in A_1$ en la medición. También es deseable que 
$t$ sea lo más pequeño posible, ya que $t$ aplicaciones de la operación $G$ requieren $t$ consultas a la función $f$, cuya ejecución se busca minimizar 
tanto como sea posible. Una forma de lograr que $sin((2t+1)\theta)$ sea cercano a 1 en valor absoluto consiste en elegir $t$ tal que 

```math 
(2t+1)\theta \approx \frac{\pi}{2}
````

Debido al comportamiento de la función seno. 

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/grover/sin_function.png`}
    alt='Comportamiento de la función seno. Probabilidad de leer una solución contra el número de iteraciones.'
    width='700'
    height='700'
  />
  <span style='width:455px; padding:10px 40px'>
    **Figura (6):** Comportamiento de la función seno. Probabilidad de leer una solución contra el número de iteraciones.
  </span>
</div>

Nota: existen infinitos valores $t$ tal que $sin(t) \approx |1|$. Además, la oscilación de dicha función permite estimar la probabilidad de éxito a la hora 
de encontrar una solución, basándose en la cantidad de iteraciones elegida. En este contexto, se buscará alcanzar el valor positivo $t$ cercano a $|1|$ más pequeño, 
con el objetivo de realizar la menor cantidad de iteraciones posible y disminuir al mínimo la probabilidad de error durante la ejecución del algoritmo.

Despejando $t$ y redondeando a un valor entero mayor que 0, de la ecuación anterior se obtiene:

```math
t = \left\lfloor\frac{\pi}{4\theta}\right\rfloor
```

Ahora debe reemplazarse el valor $\theta$. Recordando que el valor de dicho ángulo está dado por la fórmula $\theta = sin^{-1}\left(\sqrt{\frac{|A_1|}{N}}\right)$, 
puede verse fácilmente que la estimación de $t$ desarrollada previamente depende del número de cadenas presentes en $A_1$. Esto puede presentar un 
desafío si no se sabe cuántas soluciones tiene el problema.


##### Solución única

Se harán los cálculos necesarios para el caso en el que solamente hay una cadena $x$ tal que $f(x) = 1$.

```math
t = sin^{-1}\left(\sqrt{\frac{|A_1|}{N}}\right) = sin^{-1}\left(\sqrt{\frac{1}{N}}\right)
```

Cuyo valor puede aproximarse a $\sqrt{\frac{1}{N}}$ cuando $N$ es un valor grande. 

Sustituyendo el valor $\theta = \sqrt{\frac{1}{N}}$ en la expresión $t = \left\lfloor\frac{\pi}{4\theta}\right\rfloor$ se obtiene 

```math
t = \left\lfloor\frac{\pi}{4\theta}\right\rfloor = \left\lfloor\frac{\pi}{4N^{-1/2}}\right\rfloor = \left\lfloor\frac{\pi}{4}\sqrt{N}\right\rfloor
```

En base al resultado obtenido en $t$, notar que el algoritmo de Grover requiere a lo sumo $O(\sqrt{N})$ consultas para encontrar la solución.
La probabilidad de que la medición final resulte en la solución puede expresarse como 

```math
p(N,1)=sin^2((2t+1)θ))
```

Y en general se cumple 

```math
p(N,1) >= 1 - \frac{1}{N}
```

para todo $N$, por lo que la probabilidad de éxito tiende a 1 a medida que $N$ crece.


##### Múltiples soluciones

Se harán los cálculos necesarios para el caso en el que hayan distintas cadenas $x_i$ tal que $f(x_i) = 1$.

A medida que la cantidad de elementos en $A_1$ varía, también lo hace el ángulo $\theta$, lo cual puede repercutir en gran medida en la probabilidad de éxito 
del algoritmo. Teniendo $s$ soluciones, habrá que usar el siguiente ángulo:

```math
\theta=sin^{−1}\left(\sqrt{\frac{s}{N}}\right)
```

y $p(N,s)$ denota la probabilidad del algoritmo para que en $t$ iteraciones encuentre una de las $s$ soluciones dentro de $N$ posibilidades. Puede probarse que 

```math
p(N,s)\geq 1−\frac{s}{N}
```

y también que 

```math
p(N,s)\geq \frac{s}{N}
```

Para todo valor $\alpha \in \{0,1\}$ se cumple que $sin^{-1}(\alpha)\geq\alpha$, por lo que puede afirmarse la siguiente inecuación:

```math
\theta = sin^{-1}\left(\sqrt{\frac{s}{N}}\right) \geq \sqrt{\frac{s}{N}}
```

lo cual implica que 

```math
t \leq \frac{\pi}{4\theta} \leq \frac{\pi}{4} \sqrt{\frac{N}{s}}
```

Por lo tanto, se reduce la cantidad de consultas requeridas a la función $f$ a medida que $s$ aumenta. El número de consultas requeridas es de $O\left(\sqrt{\frac{N}{s}}\right)$.

##### Número desconocido de soluciones 

Si el número de soluciones $s = |A_1|$ se desconoce debe implementarse una estrategia para encontrar soluciones con alta probabilidad. Existen diferentes alternativas
que serán mencionadas a continuación. 

La primera opción consiste en elegir un valor aleatorio de $t$ ubicado entre 1 y $\left\lfloor\frac{\pi}{4}\sqrt{N}\right\rfloor$. De esta manera es posible encontrar 
una solución (asumiendo que al menos una existe) con una probabilidad mayor al 40\%. Si bien esta probabilidad es baja, repitiendo este procedimiento y verificando el 
resultado puede alcanzarse una solución con una probabilidad muy cercana a 1. 

Por otro lado, existe un método que encuentra una solución cuando al menos una existe realizando $O\left(\sqrt{\frac{N}{s}}\right)$ consultas, incluso cuando el número de 
soluciones de $s$ no es conocido. Cabe destacar que se requieren $O\left(\sqrt{N}\right)$ consultas para determinar que no hay soluciones cuando $s=0$. La idea consiste en 
elegir $t$ de manera uniforme y aleatoria dentro del conjunto $\{1,...,T\}$ iterativamente, incrementando el valor de $T$. Una estrategia válida es comenzar 
con $T=1$ e incrementar dicho valor exponencialmente, siempre terminando este proceso tan pronto como una solución sea encontrada y dejando de incrementar $T$ para 
no desperdiciar consultas cuando ya se sabe que no existe una solución. Este procedimiento tiene la ventaja de que requiere menos consultas cuando hay más soluciones.
No obstante, debe tenerse cuidado a la hora de elegir la tasa de crecimiento de $T$: está comprobado que utilizar $T \leftarrow \left\lceil \frac{5}{4}T \right\rceil$ 
funciona correctamente, pero duplicar $T$ en cada iteración es demasiado agresivo y genera incrementos demasiado rápidos. 

##### Casos triviales

Hasta este punto se ha asumido que el número de soluciones es distinto de cero. Además, se ha dejado en claro que tanto $A_0$ como $A_1$ eran conjuntos no vacíos. 
En este apartado se explicará qué ocurre cuando alguno de ambos conjuntos se encuentra vacío. 

Si todas las cadenas $x \in \Sigma^n$ son una solución, entonces cualquier medición reflejará una solución; y cuando no haya soluciones, ninguna medición obtendrá 
una solución. El hecho de que $A_0$ o $A_1$ sean vacíos implica que $f$ es una función constante: $A_1$ es vacío cuando $f(x) = 0$ para todo $x \in \Sigma^n$ y 
$A_0$ es vacío cuando $f(x) = 1$ para todo $x \in \Sigma^n$. 

Lo anterior implica que 

```math 
O\ket{u} = \pm\ket{u}
```

y por lo tanto 

```math 
G\ket{u}=(2\ket{u}\bra{u}-I)O\ket{u}=\pm(2\ket{u}\bra{u}-I)\ket{u}=\pm\ket{u}
```

En conclusión, sin importar la cantidad de iteraciones $t$ que se realicen en estos casos, las mediciones siempre reflejarán una cadena 
uniforme aleatoria $x\in\Sigma^n$.

### Ejemplos

Sea $s=11$ la solución única al problema se modifica el oráculo con una función que toma valor 1 únicamente con dicha cadena. Utilizaremos una puerta <a href={`${import.meta.env.BASE_URL}/gates/cz`}>CZ</a> para que el oráculo detecte la solución única.

<Tabs>
  <TabItem label='Quirk'>
    <Box>
      <QuantumCircuit src={grover_example} />
      <Aside>
        El resultado de la medición representa con valores **"On"** aquellos
        valores que son $1$ y los que son **"Off"** los valores que son $0$,
        formando la cadena $111$ si se lee de arriba hacia abajo.
      </Aside>
    </Box>
  </TabItem>
  <TabItem label='Qiskit'>
    <Box>
      <Tabs>
        <TabItem label='Código'>
          <Code code={solution_grover} lang='py' />
        </TabItem>
        <TabItem label='Resultado'>
          <Code
            mark={[`{'11': 1024}`]}
            lang='text'
            code={results_11_grover}
          />
          <Aside>
            El orden de la evaluación (la última linea) es de abajo hacia
            arriba, por lo que el último bit representa el de arriba.
          </Aside>
        </TabItem>
      </Tabs>
    </Box>
  </TabItem>
</Tabs>

## Más información

<Recommendations />
<BibItem id="wong" rate="r" prefix="Capítulo 7.6.3, " />
<BibItem id="nielsen" rate="a" prefix="Capítulo 6, " />
<BibItem id="groverQiskit" rate="a" />
<BibItem id="groverQC" rate="o" />
<BibItem id="oreilly" rate="o" prefix="Capítulo 10, " />
