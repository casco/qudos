---
layout: '@layouts/math.astro'
title: Algoritmo de Deutsch-Jozsa
description: Un analisis profundo sobre el algoritmo de Deutsch-Jozsa, sus componentes y sus implicaciones en la computación cuántica.
---

import { Image } from 'astro:assets'
import { Aside } from '@astrojs/starlight/components'
import Math from '@components/Math.astro'
import QuantumCircuit from '@components/QuantumCircuit.astro'
import { Code } from '@astrojs/starlight/components'

export const deutsch_none_url = `https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%5D%7D`
export const deutsch_cx_url = `https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%5D%7D`
export const deutsch_init_code = `
regs = [QuantumRegister(2, "q"), ClassicalRegister(1, "c")]
qc = QuantumCircuit(*regs)
qc.h(0)
qc.x(1)
qc.h(1)
qc.barrier()
`
export const deutsch_end_code = `
qc.barrier()
qc.h(0)
qc.measure(0, 0)
`

export const deutsch_none_qiskit = `${deutsch_init_code}# no hace nada${deutsch_end_code}`
export const deutsch_cx_qiskit = `${deutsch_init_code}qc.cx(0, 1)${deutsch_end_code}`

El algoritmo de Deutsch-Jozsa es uno de los algoritmos más conocidos en la rama cuántica, es uno de los primeros algoritmos cuánticos que es exponencialmente más rapido que su alternativa clásica. Este mismo, motivó a los algoritmos más famosos como el de Shor o el de Grover, entre muchos más.

## Objetivo

Este algoritmo resuelve el problema de búsqueda de que una función \\(f\\) sea
**constante** o **balanceada**. Una función es constante cuando \\(f\\) ante cualquier
entrada retorna siempre la misma salida, es decir siempre retorna \\(0\\) o siempre retorna \\(1\\).
Por otra parte la función es balanceada cuando retorna mitad de veces una salida y mitad de veces otra, es decir retorna \\(n/2\\) veces \\(0\\) y \\(1\\) respectivamente.

El **algoritmo clásico**, implica recorrer, en el peor de los casos, al menos mitad de las salidas posibles ($2^{n-1}+1$). El **algoritmo cuántico** realiza esta operación en **una** sola pasada.

## Deutsch-Jozsa reducido

Se plantea en un principio una versión reducida del problema, llamado el problema de Deutsch, donde la función que se evalúa posee una única entrada:

```math
f: \{0,1\} \rightarrow \{0,1\}
```

Esto permite simplificar el algoritmo en su unidad más básica, favoreciendo a que se comprenda el problema que resuelve el algoritmo. Posteriormente se explicará la versión completa del algoritmo de Deutsch-Jozsa para una función con $n$ entradas.

### Solución

Una solución posible al problema reducido definido previamente puede ser el siguiente circuito:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-jozsa-simple.png`}
    alt='Algoritmo Deutsch en un circuito con separadores ante la aplicación de cada compuerta.'
    width='455'
    height='220'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (1):** Algoritmo Deutsch en un circuito con separadores ante
    la aplicación de cada compuerta.
  </span>
</div>

En este circuito cuántico se utilizan las compuertas <a href={`${import.meta.env.BASE_URL}/gates/pauli-x`}>Pauli X</a>, <a href={`${import.meta.env.BASE_URL}/gates/hadamard`}>Hadamard</a> y un <a href={`${import.meta.env.BASE_URL}/concepts/oracles`}>oráculo</a> \\(U_f\\) que es un oráculo de fase. Notar que el oráculo de fase se encuentra asociado a \\(f\\), que es la función que estamos analizando si es constante/balanceada.

Analizaremos paso a paso el estado de los qubits segun los separadores provistos en el grafico, donde \\(\psi_i\\) es el estado en el paso \\(i\\), empezando con \\(i=0\\) y finalizando con \\(i=4\\):

```math
\begin{align}
\psi_0=&\ket{00}\\
\psi_1=&\ket{01}\\
\psi_2=&\ket{+-}\\
\psi_3=&\frac{1}{\sqrt{2}}((-1)^{f(0)}\ket{0}+(-1)^{f(1)}\ket{1})\\
\psi_4=&
\begin{cases}
H\ket{+}=\ket{0} & \text{si \(f(0)=f(1)\)}\\
H\ket{-}=\ket{1} & \text{si \(f(0) \neq f(1)\)}
\end{cases}
\end{align}
```

Un desarrollo elaborado se puede observar dentro de las <a href={`${import.meta.env.BASE_URL}/proofs/deutsch-jozsa#desarrollo-elaborado-de-la-versión-reducida`}>pruebas matemáticas</a>.

La idea básica del algoritmo es poder reemplazar $U_f$ con un circuito, si este circuito representa una función constante, la salida del primer Qubit va a ser $\ket{0}$. Por otra parte, en caso de que el circuito represente una función balanceada, retornará $\ket{1}$.

### Ejemplos

En estos ejemplos se definirán circuitos que representan tanto funciones constantes como balanceadas. Estos circuitos reemplazarán el oráculo definido previamente que abstraía la función a analizar.

<Aside>
    Estos ejemplos tienen como objetivo definir una función para demostrar que el algoritmo funciona para un caso, mientras que la versión genérica abarca todos los casos.
</Aside>

#### Funciones Constantes

Sea $f$ una función constante, un circuito posible que actue como función constante es no hacer nada.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-fn-constante.png`}
    alt='Circuito con dos qubits, siendo el primero la entrada de la función y el segundo su correspondiente salida. Denota una función constante donde f(x)=0.'
    width='504'
    height='109'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (2):** Circuito con dos qubits, siendo el primero la entrada de la
    función y el segundo su correspondiente salida. Denota una función constante
    donde $f(x)=0$.
  </span>
</div>

Notar que si $x=0$ (primer qubit en el circuito de la izquierda), el resultado de la función $f(x)$ (segundo qubit) es $0$, y de la misma manera si $x=1$ (circuito de la derecha) la salida de $f(x)$ sigue siendo $0$, es decir que $f(0)=f(1)=0$.

Por lo que si introducimos esta función/circuito dentro del algoritmo de Deutsch la salida debe ser $\ket{0}$, gráficamente se observaría de la siguiente manera:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-aplicado-constante.png`}
    alt='Algoritmo Deutsch en un gráfico con separadores ante la aplicación de cada compuerta, utilizando la función constante en vez del oráculo.'
    width='455'
    height='220'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (3):** Algoritmo Deutsch en un gráfico con separadores ante
    la aplicación de cada compuerta, utilizando la función constante en vez del
    oráculo.
  </span>
</div>

Desarrollando paso a paso el estado de los qubits según los separadores provistos:

```math
\begin{align}
\psi_0=&\ket{00}\\
\psi_1=&\ket{01}\\
\psi_2=&\ket{+-}\\
\psi_3=&\ket{0-}\\
=&\ket{0}\\
\end{align}
```

Se elimina el $\ket{-}$ ya que no es utilizado en la medición. Con este resultado llegamos rapidamente a que, con este ejemplo de función constante, se deriva correctamente al resultado de $\ket{0}$.

El simulador de <a target="_blank" href="https://algassert.com/quirk">Quirk</a>, nos permite emular y observar en sus diferentes representaciones el circuito presentado previamente.

<QuantumCircuit src={deutsch_none_url} />

Por otra parte si se desea implementar el algoritmo en **Qiskit** con este mismo oráculo de ejemplo, un código equivalente es el siguiente:

<Code
  code={deutsch_none_qiskit}
  lang='py'
  mark={['# no hace nada']}
  title='Qiskit | Deutsch con función constante'
/>

La función descrita previamente era constante y retornaba 0 ante cualquier input. Otro ejemplo de función constante es aquella que siempre retorna 1 como salida, esta se puede implementar por ejemplo aplicando una compuerta Pauli-X a la salida.

#### Funciones Balanceadas

Sea $f$ una función balanceada, un circuito posible que representa una función balanceada es utilizando una compuerta CNOT.

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-fn-balanceada.png`}
    alt='Circuito con dos qubits, siendo el primero la entrada de la función y el segundo su correspondiente salida. Denota una función balanceada'
    width='504'
    height='109'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (4):** Circuito con dos qubits, siendo el primero la entrada de la
    función y el segundo su correspondiente salida. Denota una función
    balanceada.
  </span>
</div>

Notar que si $x=0$ (primer qubit en el circuito de la izquierda), el resultado de la función $f(x)$ (segundo qubit) es $0$, y si $x=1$ (circuito de la derecha) la salida de $f(x)$ es $1$, es decir que $f(0)\neq f(1)$.

Si introducimos esta función/circuito dentro del algoritmo de Deutsch la salida, a diferencia del previo, debe ser $\ket{1}$, gráficamente se observaria de la siguiente manera:

<div style='display:flex; justify-content:center; align-items:center; flex-direction:column'>
  <Image
    src={`${import.meta.env.BASE_URL}/deutsch-aplicado-balanceada.png`}
    alt='Algoritmo Deutsch en un gráfico con separadores ante la aplicación de cada compuerta, utilizando la función balanceada en vez del oráculo.'
    width='455'
    height='220'
  />
  <span style='width:504px; padding:10px 40px'>
    **Figura (5):** Algoritmo Deutsch en un gráfico con separadores ante la aplicación de cada compuerta, utilizando la función balanceada en vez del oráculo.
  </span>
</div>

Nuevamente desarrollando paso a paso los estados de los qubits en cada separador obtenemos:

```math
\begin{align}
\psi_0=&\ket{00}\\
\psi_1=&\ket{01}\\
\psi_2=&\ket{+-}\\
\psi_3=&CNOT\ket{+-}\\
      =&\ket{--}\\
\psi_4=&\ket{1-}\\
=&\ket{1}
\end{align}
```

Una derivación del paso $\psi_3$ se puede encontrar en las <a href={`${import.meta.env.BASE_URL}/proofs/cnot`}>pruebas matemáticas de CNOT</a>. De la misma manera se elimina el $\ket{-}$ ya que no se utiliza en la medición.

Esto determina que, para este ejemplo de función balanceada, se deriva al resultado correcto, es decir que el circuito con <a href={`${import.meta.env.BASE_URL}/gates/cnot`}>CNOT</a> deriva en el resultado $\ket{1}$. También se puede observar en el simulador como cambió el estado de _"Off"_ a _"On"_.

<QuantumCircuit src={deutsch_cx_url} />

Por otra parte si se desea implementar el algoritmo en **Qiskit** con este mismo oráculo de ejemplo, un código equivalente es el siguiente:

<Code
  code={deutsch_cx_qiskit}
  lang='py'
  mark={['qc.cx(0, 1)']}
  title='Qiskit | Deutsch con CNOT'
/>

La función descrita previamente era balanceada retornando el mismo valor que el input (función identidad). Otro ejemplo de función balanceada es aquella que siempre retorna el opuesto de la entrada como salida (función de opuesto), esta se puede implementar, por ejemplo, aplicando una compuerta Pauli-X a la salida luego de haber aplicado un CNOT.

## Más información

- <a href='https://www.youtube.com/watch?v=eE7eumEZOSE' target='_blank'>
    "Consulting the (phase) oracle" (Chris Ferrie) [Inglés]
  </a>
- <a href='https://youtu.be/_BHvE_pwF6E?si=mg6nYrRbRtzRecEh' target='_blank'>
    "Deutsch Jozsa Algorithm - Quantum Computer Programming w/ Qiskit p.3"
    (sentdex) [Inglés]
  </a>
- <a href='https://www.youtube.com/watch?v=pC2XRXInHnc' target='_blank'>
    "Quantum Computing Course: 3.4 Deutsch-Jozsa Algorithm" (Quantum Soar)
    [Inglés]
  </a>
- Páginas 32-36, <a href='https://isbnsearch.org/isbn/9781107002173' target='_blank'>Quantum Computation and Quantum Information: 10th Anniversary Edition (Michael A. Nielsen; Isaac L. Chuang) [Inglés]</a>
- Páginas 302-303, <a href='https://isbnsearch.org/isbn/9781492039686' target='_blank'>Programming Quantum Computers: Essential Algorithms and Code Samples (Eric Johnston; Nic Harrigan; Mercedes Gimeno-Segovia) [Inglés]</a>
